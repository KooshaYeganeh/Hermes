#!/bin/bash

# LinuxAV-Solutions Command Line Tool with Enterprise EDR Capabilities
# Version: 4.0
# Features: Centralized Management, Threat Intelligence Integration, Behavioral Analysis, 
#           Automated Response, Compliance Reporting, SIEM Integration, Suricata IDS/IPS

## Global Configuration


CONFIG_FILE="myEDR.conf"

## Colors for reporting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color


mkdir -p "$SIGNATURES_DIR" "$RULES_DIR/yara"
touch "$SIGNATURES_DIR"/{malicious_ips.txt,malware_hashes.txt,malicious_domains.txt}

load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        # Check config file syntax first
        if ! bash -n "$CONFIG_FILE"; then
            echo "Error: Invalid configuration file syntax" >&2
            exit 1
        fi
        
        # Load the configuration
        source "$CONFIG_FILE"
        
        # Validate critical settings
        if [ -z "$APPDIR" ] || [ -z "$LOG_DIR" ]; then
            echo "Error: Invalid base directories in config" >&2
            exit 1
        fi
    else
        echo "Error: Configuration file $CONFIG_FILE not found" >&2
        exit 1
    fi
}

start_daemon() {
    if [ -f "$PIDFILE" ]; then
        if kill -0 $(cat "$PIDFILE") 2>/dev/null; then
            echo "EDR daemon is already running (PID: $(cat "$PIDFILE"))"
            return 1
        else
            rm -f "$PIDFILE"
        fi
    fi
    
    echo "Starting EDR daemon..."
    nohup "$0" --daemon </dev/null >"$LOGFILE" 2>&1 &
    echo $! > "$PIDFILE"
}

stop_daemon() {
    if [ -f "$PIDFILE" ]; then
        echo "Stopping EDR daemon..."
        kill $(cat "$PIDFILE")
        rm -f "$PIDFILE"
        return 0
    else
        echo "EDR daemon is not running"
        return 1
    fi
}

status_daemon() {
    if [ -f "$PIDFILE" ]; then
        if kill -0 $(cat "$PIDFILE") 2>/dev/null; then
            echo "EDR daemon is running (PID: $(cat "$PIDFILE"))"
            return 0
        else
            echo "EDR daemon PID file exists but process not running"
            return 1
        fi
    else
        echo "EDR daemon is not running"
        return 1
    fi
}

# Main daemon loop
daemon_loop() {
    # Load configuration
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
    fi
    
    # Initialize
    init_directories
    
    # Main loop
    while true; do
        # Run all automated checks
        automated_scan
        
        # Sleep until next run
        sleep $INTERVAL
    done
}


automated_scan() {
    local timestamp=$(date --iso-8601=seconds)
    log_event "INFO" "Starting automated EDR scan cycle"
    
    # Run all detection modules
    check_malicious_connections
    check_abnormal_ports
    check_abnormal_processes
    monitor_files  # This should be modified to run once rather than continuously
    vulnerability_scan
    hunt_suspicious_activity
    scan_with_clamav
    scan_with_maldet
    scan_with_yara
    
    # Behavioral analysis
    analyze_behavior
    
    # Compliance reporting
    generate_compliance_report
    
    log_event "INFO" "Completed automated EDR scan cycle"
}

# Initialize directories and enterprise environment
init_directories() {
    # Create main application directories with proper permissions
    mkdir -p "$APPDIR" "$LOG_DIR" "$QUARANTINE_DIR" "$SIGNATURES_DIR" "$EDR_DIR" \
             "$BASELINE_DIR" "$CONFIG_DIR" "$RULES_DIR" "$REPORT_DIR"
    
    # Set secure permissions (root:root, 750 for dirs, 640 for files)
    chown -R root:root "$APPDIR"
    chmod -R 750 "$APPDIR"
    chmod 770 "$QUARANTINE_DIR"  # Needs write access for moving files
    
    # Create default signature database if not exists
    if [ ! -f "$MALWARE_SIGNATURES" ]; then
        echo "# MD5 malware signatures database" > "$MALWARE_SIGNATURES"
        echo "# Format: md5_hash:signature_name:severity" >> "$MALWARE_SIGNATURES"
        echo "d41d8cd98f00b204e9800998ecf8427e:TEST_SIGNATURE:info" >> "$MALWARE_SIGNATURES"
        chmod 640 "$MALWARE_SIGNATURES"
    fi
    
    # Create default malicious IPs list if not exists
    if [ ! -f "$MALICIOUS_IPS" ]; then
        echo "# Known malicious IP addresses" > "$MALICIOUS_IPS"
        echo "# Format: ip_address:threat_type:severity:description" >> "$MALICIOUS_IPS"
        echo "123.123.123.123:scanner:high:Known port scanner" >> "$MALICIOUS_IPS"
        chmod 640 "$MALICIOUS_IPS"
    fi
    
    # Create default YARA rules if not exists
    if [ ! -f "$RULES_DIR/malware_rules.yar" ]; then
        cat > "$RULES_DIR/malware_rules.yar" << 'EOL'
rule Test_Malware {
    meta:
        description = "Test rule for Linux EDR"
        severity = "high"
    strings:
        $test_string = "malicious_test_string"
    condition:
        $test_string
}
EOL
        chmod 640 "$RULES_DIR/malware_rules.yar"
    fi
    
    # Create default EDR rules if not exists
    if [ ! -f "$RULES_DIR/process_rules.txt" ]; then
        cat > "$RULES_DIR/process_rules.txt" << 'EOL'
# EDR Process Monitoring Rules
# Format: process_name:severity:action:description
nc:high:alert:Netcat network tool
socat:high:alert:Socat network tool
miner:critical:kill:Cryptocurrency miner
EOL
        chmod 640 "$RULES_DIR/process_rules.txt"
    fi
    
    if [ ! -f "$RULES_DIR/file_rules.txt" ]; then
        cat > "$RULES_DIR/file_rules.txt" << 'EOL'
# EDR File Monitoring Rules
# Format: path:permission_changes:content_changes:description
/etc/passwd:alert:critical:System user database
/etc/shadow:alert:critical:Encrypted user passwords
/root/.ssh/:critical:critical:SSH keys for root
EOL
        chmod 640 "$RULES_DIR/file_rules.txt"
    fi
    
    # Initialize event log with JSON format
    if [ ! -f "$EVENT_LOG" ]; then
        cat > "$EVENT_LOG" << 'EOL'
{
    "events": [
        {
            "timestamp": "2023-01-01T00:00:00Z",
            "type": "system",
            "severity": "info",
            "message": "EDR system initialized",
            "host": "localhost"
        }
    ]
}
EOL
        chmod 640 "$EVENT_LOG"
    fi
    
    # Handle Suricata integration properly
    if [ -d "/etc/suricata" ]; then
        # Link to existing Suricata directories
        [ ! -L "$APPDIR/suricata_rules" ] && ln -s "/etc/suricata/rules" "$APPDIR/suricata_rules"
        [ ! -L "$APPDIR/suricata_logs" ] && ln -s "/var/log/suricata" "$APPDIR/suricata_logs"
        
        # Ensure Suricata can write to its directories
        chown -R suricata:suricata "/etc/suricata" "/var/log/suricata"
        chmod -R 750 "/etc/suricata"
        chmod -R 770 "/var/log/suricata"
    else
        mkdir -p "$APPDIR/suricata_rules" "$APPDIR/suricata_logs"
        # Create minimal Suricata rule if Suricata not installed
        if [ ! -f "$APPDIR/suricata_rules/local.rules" ]; then
            echo 'alert ip any any -> any any (msg:"EDR TEST RULE"; sid:1000001; rev:1;)' \
                > "$APPDIR/suricata_rules/local.rules"
        fi
    fi
    
    # Initialize enterprise environment
    init_enterprise
    
    # Create initial baseline if none exists
    if [ ! -f "$BASELINE_DIR/filesystem.csv" ]; then
        log_event "system" "info" "Creating initial system baseline"
        create_baseline
    fi
}

## Initialize Enterprise Environment
init_enterprise() {
    # Create necessary directories
    mkdir -p ${CONFIG_DIR} /var/log/edr /var/lib/edr/{quarantine,artifacts} \
             /var/run/edr ${TEMP_DIR}
    
    # Load configuration
    if [ -f "${CONFIG_FILE}" ]; then
        source "${CONFIG_FILE}"
    else
        generate_enterprise_config
    fi
    
    # Set up logging
    exec 2>>"${LOG_DIR}/edr_error.log"
    
    # Check for central configuration updates
    check_config_updates
    
    # Initialize Suricata if installed
    if command -v suricata &>/dev/null; then
        init_suricata
    fi
}

## Initialize Suricata IDS/IPS
init_suricata() {
    # Check if Suricata is running
    if ! pgrep -x "suricata" >/dev/null; then
        # Start Suricata in IDS mode
        suricata -c /etc/suricata/suricata.yaml -i $(ip route get 1 | awk '{print $5;exit}') -D
        
        if [ $? -eq 0 ]; then
            log_event "INFO" "Suricata IDS/IPS started successfully"
        else
            log_event "ERROR" "Failed to start Suricata IDS/IPS"
        fi
    fi
    
    # Update Suricata rules periodically
    update_suricata_rules
}

update_suricata_rules() {
    # Check if rule update is needed (once per day)
    local last_update=0
    if [ -f "$SURICATA_DIR/last_update" ]; then
        last_update=$(date -r "$SURICATA_DIR/last_update" +%s)
    fi
    local current_time=$(date +%s)
    
    if (( current_time - last_update > 86400 )); then
        log_event "INFO" "Updating Suricata rules"
        
        # Pull ET Open rules
        if wget https://rules.emergingthreats.net/open/suricata-6.0.0/emerging.rules.tar.gz | \
           tar xz -C emerging.rules.tar.gz; then
            touch "$SURICATA_DIR/last_update"
            log_event "INFO" "Suricata rules updated successfully"
            
            # Reload Suricata if running
            if pgrep -x "suricata" >/dev/null; then
                suricatasc -c reload-rules
            fi
        else
            sudo suricata-update
            log_event "ERROR" "Failed to update Suricata rules"
        fi
    fi
}

## Enterprise Configuration Generator
generate_enterprise_config() {
    cat > "${CONFIG_FILE}" <<EOF
# Enterprise EDR Configuration
# Auto-generated on $(date)

# Directory Configuration
LOG_DIR="/var/log/edr"
REPORT_DIR="/var/reports/edr"
QUARANTINE_DIR="/var/lib/edr/quarantine"
ARTIFACT_DIR="/var/lib/edr/artifacts"

# Network Configuration
CENTRAL_MGMT_SERVER="edr-mgmt.corporate.com"
SIEM_SERVER="siem.corporate.com:514"
THREAT_INTEL_API="https://ti.corporate.com/api/v1/check"

# Scanning Configuration
SCAN_DIRS="/home /etc /bin /usr/bin /usr/sbin /opt"
YARA_RULES_DIR="/etc/edr/yara_rules"
SIGNATURE_DB="/etc/edr/signatures.db"

# Response Configuration
AUTO_CONTAINMENT_LEVEL="high"
NETWORK_ISOLATION_THRESHOLD=3

# Monitoring Configuration
ENABLE_BEHAVIORAL_MONITORING=true
ENABLE_REALTIME_PROCESS_MONITORING=true
ENABLE_FILE_INTEGRITY_MONITORING=true
ENABLE_SURICATA=true

# Notification Configuration
SECURITY_TEAM_EMAIL="security-team@corporate.com"
INCIDENT_RESPONSE_PAGER="ir-team@corporate.com"

# Compliance Configuration
COMPLIANCE_STANDARD="PCI DSS 3.2"
REQUIRED_CHECKS="file_integrity,user_accounts,firewall_rules,audit_config"

# Advanced Configuration
MAX_LOG_SIZE="100M"
LOG_RETENTION_DAYS=90
EOF

    chmod 600 "${CONFIG_FILE}"
}

## Centralized Management Functions
check_config_updates() {
    local last_update=$(stat -c %Y "${CONFIG_FILE}" 2>/dev/null || echo 0)
    local current_time=$(date +%s)
    
    if (( current_time - last_update > 3600 )); then
        log_event "INFO" "Checking for configuration updates from central server"
        
        if curl -s --connect-timeout 10 --cert ${CONFIG_DIR}/client.pem \
           "https://${CENTRAL_MGMT_SERVER}/config/${MACHINE_ID}" -o "${TEMP_DIR}/new_config"; then
            
            if validate_config "${TEMP_DIR}/new_config"; then
                mv "${TEMP_DIR}/new_config" "${CONFIG_FILE}"
                log_event "INFO" "Configuration updated from central server"
                source "${CONFIG_FILE}"
            fi
        fi
    fi
}

validate_config() {
    local config_file=$1
    # Basic validation - ensure it's a proper bash file
    return $(bash -n "${config_file}" 2>/dev/null)
}

## Enhanced Logging Framework
log_event() {
    local severity=$1
    local message=$2
    local timestamp=$(date --iso-8601=seconds)
    local log_entry="[${timestamp}] [${severity}] ${message}"
    
    # Local logging
    echo "${log_entry}" >> "${LOG_DIR}/edr_${current_date}.log"
    echo "${timestamp},${severity},${message}" >> "${EVENT_LOG}"
    
    # SIEM integration (if configured)
    if [ -n "${SIEM_SERVER}" ]; then
        echo "<14>${timestamp} ${HOSTNAME} EDR[$$]: ${severity}: ${message}" | \
            nc -w 2 -u "${SIEM_SERVER}" 2>/dev/null
    fi
    
    # Central logging (if configured)
    if [ -n "${CENTRAL_MGMT_SERVER}" ]; then
        curl -s -X POST --connect-timeout 3 --cert ${CONFIG_DIR}/client.pem \
             -d "host=${MACHINE_ID}&group=${DEPLOYMENT_GROUP}&severity=${severity}&message=${message}" \
             "https://${CENTRAL_MGMT_SERVER}/logs" >/dev/null
    fi
}

## Threat Intelligence Integration
check_threat_intel() {
    local indicator=$1
    local indicator_type=$2  # ip, hash, domain, url
    
    # First check local threat databases
    local local_result=$(check_local_threat_db "$indicator" "$indicator_type")
    [ -n "$local_result" ] && echo "$local_result" && return
    
    # Then check online sources if configured
    if [ -n "${THREAT_INTEL_API}" ]; then
        local response=$(curl -s --connect-timeout 5 --cert ${CONFIG_DIR}/client.pem \
            "${THREAT_INTEL_API}/${indicator_type}/${indicator}")
        
        if echo "${response}" | jq -e '.match == true' >/dev/null; then
            local threat_level=$(echo "${response}" | jq -r '.threat_level')
            local threat_name=$(echo "${response}" | jq -r '.threat_name')
            echo "${threat_level} ${threat_name}" && return
        fi
    fi
    
    # Fallback to other open-source intelligence feeds
    check_osint_feeds "$indicator" "$indicator_type"
}

check_local_threat_db() {
    local indicator=$1
    local type=$2
    
    # Check against local threat databases
    case $type in
        "ip")
            grep -q "^$indicator$" "$SIGNATURES_DIR/malicious_ips.txt" && echo "high Known malicious IP"
            ;;
        "hash")
            grep -q "$indicator" "$SIGNATURES_DIR/malware_hashes.txt" && echo "high Known malware hash"
            ;;
        "domain")
            grep -q "$indicator" "$SIGNATURES_DIR/malicious_domains.txt" && echo "medium Suspicious domain"
            ;;
    esac
}




update_local_threat_dbs() {
    # IP addresses
    curl -s https://rules.emergingthreats.net/blockrules/compromised-ips.txt \
        >> "$SIGNATURES_DIR/malicious_ips.txt"
    
    # Malware hashes
    curl -s https://virusshare.com/hashes.txt \
        >> "$SIGNATURES_DIR/malware_hashes.txt"
    
    # Malicious domains
    curl -s https://mirror.cedia.org.ec/malwaredomains/justdomains \
        >> "$SIGNATURES_DIR/malicious_domains.txt"
    
    # Deduplicate and sort
    for db in ips hashes domains; do
        sort -u "$SIGNATURES_DIR/malicious_${db}.txt" -o "$SIGNATURES_DIR/malicious_${db}.txt"
    done
}




check_osint_feeds() {
    local indicator=$1
    local type=$2
    
    # VirusTotal API (requires API key in config)
    if [ -n "$VIRUSTOTAL_API_KEY" ]; then
        local vt_result=$(curl -s --connect-timeout 5 \
            "https://www.virustotal.com/api/v3/${type}s/$indicator" \
            -H "x-apikey: $VIRUSTOTAL_API_KEY")
        
        if echo "$vt_result" | jq -e '.data.attributes.last_analysis_stats.malicious > 0' >/dev/null; then
            local malicious=$(echo "$vt_result" | jq -r '.data.attributes.last_analysis_stats.malicious')
            echo "high Detected by $malicious vendors on VirusTotal"
            return
        fi
    fi
    
    # AbuseIPDB (requires API key)
    if [ "$type" = "ip" ] && [ -n "$ABUSEIPDB_API_KEY" ]; then
        local abuse_result=$(curl -s --connect-timeout 5 \
            "https://api.abuseipdb.com/api/v2/check?ipAddress=$indicator" \
            -H "Key: $ABUSEIPDB_API_KEY" -H "Accept: application/json")
        
        local score=$(echo "$abuse_result" | jq -r '.data.abuseConfidenceScore')
        [ "$score" -gt 50 ] && echo "high AbuseIPDB confidence score $score%"
        [ "$score" -gt 25 ] && echo "medium AbuseIPDB confidence score $score%"
    fi
    
    # Check against MISP instance if configured
    if [ -n "$MISP_URL" ] && [ -n "$MISP_API_KEY" ]; then
        local misp_result=$(curl -s --connect-timeout 5 \
            "$MISP_URL/attributes/restSearch/value:$indicator" \
            -H "Authorization: $MISP_API_KEY" -H "Accept: application/json")
        
        if echo "$misp_result" | jq -e '.response.Attribute | length > 0' >/dev/null; then
            local threat_level=$(echo "$misp_result" | jq -r '.response.Attribute[0].threat_level_id')
            case $threat_level in
                "1") echo "high MISP threat" ;;
                "2") echo "medium MISP threat" ;;
                "3") echo "low MISP threat" ;;
                *) echo "info MISP reference" ;;
            esac
        fi
    fi
}

## Behavioral Analysis Engine
analyze_behavior() {
    # Capture process tree snapshot
    ps -eo pid,ppid,user,cmd --forest > "${TEMP_DIR}/process_tree.txt"
    
    # Network connections analysis
    netstat -tulnpe > "${TEMP_DIR}/network_connections.txt"
    
    # File activity analysis
    lsof +L1 > "${TEMP_DIR}/deleted_files.txt"
    
    # Suricata alerts analysis
    if [ -f "${SURICATA_LOGS}/fast.log" ]; then
        cp "${SURICATA_LOGS}/fast.log" "${TEMP_DIR}/suricata_alerts.txt"
    fi
    
    # Send to central analysis (async) if configured
    if [ -n "${CENTRAL_MGMT_SERVER}" ]; then
        (tar czf - -C "${TEMP_DIR}" process_tree.txt network_connections.txt deleted_files.txt suricata_alerts.txt 2>/dev/null | \
         curl -s -X POST --connect-timeout 10 --cert ${CONFIG_DIR}/client.pem \
         --data-binary @- "https://${CENTRAL_MGMT_SERVER}/behavior/${MACHINE_ID}" >/dev/null) &
    fi
}

## Enhanced Response Framework
contain_threat() {
    local threat_level=$1
    local threat_type=$2
    local indicator=$3
    
    # Log the threat
    log_event "THREAT" "$threat_level" "Detected $threat_type threat: $indicator"
    
    # Automated response based on threat level and configuration
    case "${threat_level}" in
        "critical")
            # Immediate isolation
            isolate_host
            quarantine_artifacts "${threat_type}" "${indicator}"
            notify_security_team "CRITICAL" "Automatically contained critical ${threat_type} threat: ${indicator}"
            
            # Additional actions
            if [ "$threat_type" = "process" ]; then
                pkill -9 "$indicator"
            fi
            ;;
        "high")
            # Block network activity
            block_network "${threat_type}" "${indicator}"
            quarantine_artifacts "${threat_type}" "${indicator}"
            notify_security_team "HIGH" "Automatically contained high ${threat_type} threat: ${indicator}"
            ;;
        *)
            # Log and alert based on configuration
            if [ "$ALERT_THRESHOLD" = "all" ] || 
               [ "$ALERT_THRESHOLD" = "medium" && "$threat_level" = "medium" ] || 
               [ "$threat_level" = "high" ] || 
               [ "$threat_level" = "critical" ]; then
                notify_security_team "MEDIUM" "Detected ${threat_type} threat: ${indicator}"
            fi
            ;;
    esac
    
    # Additional automated response
    case "$threat_type" in
        "file")
            if [ "$AUTO_QUARANTINE" = "true" ]; then
                quarantine_path="${indicator/$path/$QUARANTINE_DIR}"
                mkdir -p "$(dirname "$quarantine_path")"
                mv "$indicator" "$quarantine_path"
                log_event "QUARANTINE" "info" "Automatically quarantined file: $indicator"
            fi
            ;;
        "ip")
            # Add to persistent firewall rules
            iptables-save | grep -q "$indicator" || {
                iptables -A INPUT -s "$indicator" -j DROP
                iptables -A OUTPUT -d "$indicator" -j DROP
            }
            ;;
    esac
}



init_real_time_monitoring() {
    # Set up inotifywait for critical directories
    local watch_dirs="/etc /bin /usr/bin /usr/sbin /home"
    
    # Start monitoring in the background
    inotifywait -m -r -e create,delete,modify,move $watch_dirs 2>/dev/null | \
    while read -r directory event file; do
        log_event "FSMON" "info" "File system event: $directory $file $event"
        
        # Check if modified file matches any rules
        if [ "$event" = "MODIFY" ] || [ "$event" = "CREATE" ]; then
            full_path="$directory$file"
            if [ -f "$full_path" ]; then
                result=$(check_file_signatures "$full_path")
                if [ "$result" != "Clean" ]; then
                    log_event "THREAT" "high" "Malicious file detected: $full_path (Signature: $result)"
                    contain_threat "high" "file" "$full_path"
                fi
            fi
        fi
    done &
    
    # Monitor process events
    while true; do
        ps -eo pid,comm | while read -r pid comm; do
            if [ "$pid" != "PID" ]; then
                if grep -q "$comm" "$RULES_DIR/process_rules.txt"; then
                    severity=$(grep "$comm" "$RULES_DIR/process_rules.txt" | cut -d: -f2)
                    log_event "PROCMON" "$severity" "Suspicious process running: $comm (PID: $pid)"
                    contain_threat "$severity" "process" "$comm"
                fi
            fi
        done
        sleep 10
    done &
}




isolate_host() {
    log_event "CRITICAL" "Initiating host isolation procedures"
    
    # Network isolation
    iptables -P INPUT DROP
    iptables -P OUTPUT DROP
    iptables -P FORWARD DROP
    
    # Process containment
    pkill -STOP -f "${malicious_process_patterns}"
    
    # Central alert
    if [ -n "${CENTRAL_MGMT_SERVER}" ]; then
        curl -s -X POST --connect-timeout 5 --cert ${CONFIG_DIR}/client.pem \
             -d "host=${MACHINE_ID}&action=isolated" \
             "https://${CENTRAL_MGMT_SERVER}/response" >/dev/null
    fi
}

block_network() {
    local threat_type=$1
    local indicator=$2
    
    case "$threat_type" in
        "ip")
            iptables -A INPUT -s "$indicator" -j DROP
            iptables -A OUTPUT -d "$indicator" -j DROP
            log_event "NETWORK" "Blocked network traffic to/from $indicator"
            ;;
        "port")
            iptables -A INPUT -p tcp --dport "$indicator" -j DROP
            iptables -A OUTPUT -p tcp --dport "$indicator" -j DROP
            log_event "NETWORK" "Blocked traffic on port $indicator"
            ;;
        "domain")
            # Add to /etc/hosts to null route
            echo "0.0.0.0 $indicator" >> /etc/hosts
            log_event "NETWORK" "Null routed domain $indicator"
            ;;
    esac
}

## Compliance Reporting
generate_compliance_report() {
    local report_file="${REPORT_DIR}/compliance_$(date +%Y%m%d).json"
    
    # Collect compliance data
    local compliance_data=$(cat <<EOF
{
    "timestamp": "$(date --iso-8601=seconds)",
    "host": "${MACHINE_ID}",
    "group": "${DEPLOYMENT_GROUP}",
    "checks": {
        "file_integrity": $(check_file_integrity),
        "user_accounts": $(check_user_accounts),
        "firewall_rules": $(check_firewall),
        "audit_config": $(check_audit_config),
        "suricata_status": $(check_suricata_status)
    }
}
EOF
    )
    
    echo "${compliance_data}" > "${report_file}"
    
    # Generate visual report
    generate_visual_report "${report_file}"
    
    # Upload to central server if configured
    if [ -n "${CENTRAL_MGMT_SERVER}" ]; then
        curl -s -X POST --connect-timeout 10 --cert ${CONFIG_DIR}/client.pem \
             -H "Content-Type: application/json" \
             --data-binary @"${report_file}" \
             "https://${CENTRAL_MGMT_SERVER}/compliance" >/dev/null
    fi
}

## Visual Reporting with termgraph
generate_visual_report() {
    local report_file=$1
    local visual_report="${REPORT_DIR}/compliance_$(date +%Y%m%d)_visual.txt"
    
    # Extract data for visualization
    local file_integrity=$(jq '.checks.file_integrity.score' "$report_file")
    local user_accounts=$(jq '.checks.user_accounts.score' "$report_file")
    local firewall=$(jq '.checks.firewall_rules.score' "$report_file")
    local audit=$(jq '.checks.audit_config.score' "$report_file")
    local suricata=$(jq '.checks.suricata_status.score' "$report_file")
    
    # Create termgraph data
    cat > "${TEMP_DIR}/compliance.dat" <<EOF
# Compliance Scores
File Integrity,${file_integrity}
User Accounts,${user_accounts}
Firewall,${firewall}
Audit Config,${audit}
Suricata,${suricata}
EOF
    
    # Generate visual report
    echo -e "\n${BLUE}=== COMPLIANCE REPORT ===${NC}\n" > "$visual_report"
    termgraph "${TEMP_DIR}/compliance.dat" --color {green,yellow,red} >> "$visual_report"
    
    # Add recommendations
    echo -e "\n${YELLOW}=== RECOMMENDATIONS ===${NC}" >> "$visual_report"
    
    if (( $(echo "$file_integrity < 80" | bc -l) )); then
        echo "- Investigate file integrity issues (Score: $file_integrity)" >> "$visual_report"
    fi
    
    if (( $(echo "$user_accounts < 90" | bc -l) )); then
        echo "- Review user account configurations (Score: $user_accounts)" >> "$visual_report"
    fi
    
    if (( $(echo "$firewall < 85" | bc -l) )); then
        echo "- Strengthen firewall rules (Score: $firewall)" >> "$visual_report"
    fi
    
    if (( $(echo "$audit < 75" | bc -l) )); then
        echo "- Improve audit configuration (Score: $audit)" >> "$visual_report"
    fi
    
    if (( $(echo "$suricata < 70" | bc -l) )); then
        echo "- Check Suricata IDS/IPS configuration (Score: $suricata)" >> "$visual_report"
    fi
    
    # Display the report
    cat "$visual_report"
}

check_file_integrity() {
    # Simulate file integrity check
    local score=$((80 + RANDOM % 20))
    cat <<EOF
{
    "status": "$(if [ $score -gt 85 ]; then echo "good"; else echo "needs improvement"; fi)",
    "score": $score,
    "issues": $(if [ $score -lt 85 ]; then echo 3; else echo 0; fi)
}
EOF
}

check_user_accounts() {
    # Simulate user account check
    local score=$((85 + RANDOM % 15))
    cat <<EOF
{
    "status": "$(if [ $score -gt 90 ]; then echo "excellent"; else echo "good"; fi)",
    "score": $score,
    "issues": $(if [ $score -lt 90 ]; then echo 2; else echo 0; fi)
}
EOF


check_suricata_alerts() {
    if [ -f "$SURICATA_EVE_LOG" ]; then
        # Parse eve.json for alerts
        local alerts=$(jq 'select(.event_type == "alert")' "$SURICATA_EVE_LOG" 2>/dev/null)
        
        if [ -n "$alerts" ]; then
            while read -r alert; do
                local sig_id=$(echo "$alert" | jq -r '.alert.signature_id')
                local message=$(echo "$alert" | jq -r '.alert.signature')
                local severity=$(echo "$alert" | jq -r '.alert.severity')
                
                log_event "SURICATA" "$severity" "Alert $sig_id: $message"
                
                # Automated response based on severity
                if [ "$severity" -ge 3 ]; then
                    contain_threat "high" "network" "$sig_id"
                fi
            done <<< "$alerts"
        fi
    fi
}
}

scan_with_yara() {
    local target=$1
    local yara_rules_dir="$RULES_DIR/yara"
    
    if [ "$YARA_ENABLED" != "true" ]; then
        return
    fi

    # Check for updated YARA rules daily
    if [ ! -f "$yara_rules_dir/.last_updated" ] || \
       [ $(date +%s -d "1 day ago") -gt $(date +%s -r "$yara_rules_dir/.last_updated") ]; then
        update_yara_rules
    fi

    # Scan with all YARA rules
    find "$yara_rules_dir" -name '*.yar' -exec yara -r {} "$target" \; | while read -r result; do
        [ -n "$result" ] && log_threat "YARA_MATCH" "$result" "$target" "high"
    done
}

update_yara_rules() {
    # Download from multiple open-source YARA rule repositories
    declare -A yara_sources=(
        ["https://github.com/Yara-Rules/rules.git"]="malware"
        ["https://github.com/Neo23x0/signature-base.git"]="signature-base/yara"
        ["https://github.com/elastic/protections-artifacts.git"]="main/yara"
    )

    mkdir -p "$yara_rules_dir"
    for repo in "${!yara_sources[@]}"; do
        git clone --depth 1 "$repo" "$yara_rules_dir/tmp_${repo##*/}"
        cp -r "$yara_rules_dir/tmp_${repo##*/}/${yara_sources[$repo]}"/*.yar "$yara_rules_dir/"
        rm -rf "$yara_rules_dir/tmp_${repo##*/}"
    done

    touch "$yara_rules_dir/.last_updated"
}

check_firewall() {
    # Simulate firewall check
    local score=$((75 + RANDOM % 25))
    cat <<EOF
{
    "status": "$(if [ $score -gt 85 ]; then echo "strong"; elif [ $score -gt 70 ]; then echo "adequate"; else echo "weak"; fi)",
    "score": $score,
    "issues": $(if [ $score -lt 85 ]; then echo 4; else echo 0; fi)
}
EOF
}

check_audit_config() {
    # Simulate audit config check
    local score=$((60 + RANDOM % 35))
    cat <<EOF
{
    "status": "$(if [ $score -gt 75 ]; then echo "sufficient"; else echo "insufficient"; fi)",
    "score": $score,
    "issues": $(if [ $score -lt 75 ]; then echo 5; else echo 1; fi)
}
EOF
}

check_suricata_status() {
    # Check Suricata status
    if pgrep -x "suricata" >/dev/null; then
        local score=$((70 + RANDOM % 25))
        cat <<EOF
{
    "status": "running",
    "score": $score,
    "alerts": $(if [ $score -lt 80 ]; then echo 10; else echo 3; fi)
}
EOF
    else
        cat <<EOF
{
    "status": "not running",
    "score": 0,
    "alerts": 0
}
EOF
    fi
}

# System Status Functions
get_system_status() {
    local command=$1
    local result=$(eval "$command" 2>/dev/null || echo "Unknown")
    echo "$result"
}

se_status() {
    get_system_status "sestatus | grep 'Current mode' | awk {'print \$3'}"
}

firewall_status() {
    get_system_status "systemctl is-active firewalld"
}

network_manager_status() {
    get_system_status "systemctl is-active NetworkManager"
}

clam_status() {
    get_system_status "systemctl is-active clamav-freshclam"
}

fail2ban_status() {
    get_system_status "systemctl is-active fail2ban"
}

suricata_status() {
    if pgrep -x "suricata" >/dev/null; then
        echo "Running"
    else
        echo "Not running"
    fi
}

app_disk_usage() {
    get_system_status "du -h $APPDIR | tail -1 | awk '{print \$1}'"
}

num_quarantine() {
    find "$QUARANTINE_DIR" -type f | wc -l
}

# EDR Baseline Functions
create_baseline() {
    echo "Creating system baseline..."
    
    # File system baseline
    echo "Creating filesystem baseline..."
    find / -type f -exec stat --format="%n,%U,%G,%a,%F,%y,%z" {} \; 2>/dev/null > "$BASELINE_DIR/filesystem.csv"
    
    # Process baseline
    echo "Creating process baseline..."
    ps -eo pid,user,group,cmd > "$BASELINE_DIR/processes.txt"
    
    # Network baseline
    echo "Creating network baseline..."
    netstat -tulnp > "$BASELINE_DIR/network.txt"
    
    # User/group baseline
    echo "Creating user/group baseline..."
    cat /etc/passwd > "$BASELINE_DIR/passwd.baseline"
    cat /etc/group > "$BASELINE_DIR/group.baseline"
    cat /etc/shadow > "$BASELINE_DIR/shadow.baseline" 2>/dev/null
    
    # Kernel modules
    echo "Creating kernel modules baseline..."
    lsmod > "$BASELINE_DIR/kernel_modules.txt"
    
    # Cron jobs
    echo "Creating cron jobs baseline..."
    crontab -l > "$BASELINE_DIR/crontab_root.txt" 2>/dev/null
    for user in $(cut -f1 -d: /etc/passwd); do
        crontab -u "$user" -l > "$BASELINE_DIR/crontab_$user.txt" 2>/dev/null
    done
    
    # Suricata rules checksum
    if [ -f "/etc/suricata/suricata.yaml" ]; then
        md5sum /etc/suricata/suricata.yaml > "$BASELINE_DIR/suricata_checksum.txt"
    fi
    
    log_event "baseline" "info" "System baseline created"
    echo "System baseline created at $BASELINE_DIR"
}

check_deviations() {
    echo "Checking for system deviations from baseline..."
    
    # Check filesystem changes
    if [ -f "$BASELINE_DIR/filesystem.csv" ]; then
        echo -e "\n[+] Checking for filesystem changes..."
        find / -type f -exec stat --format="%n,%U,%G,%a,%F,%y,%z" {} \; 2>/dev/null > "$BASELINE_DIR/filesystem_current.csv"
        diff "$BASELINE_DIR/filesystem.csv" "$BASELINE_DIR/filesystem_current.csv" | grep '^>' | while read -r line; do
            log_event "filesystem" "warning" "File change detected: ${line:2}"
        done
    fi
    
    # Check user/group changes
    echo -e "\n[+] Checking for user/group changes..."
    if [ -f "$BASELINE_DIR/passwd.baseline" ]; then
        diff "$BASELINE_DIR/passwd.baseline" /etc/passwd | grep '^>' | while read -r line; do
            log_event "user" "alert" "User account change: ${line:2}"
        done
    fi
    
    if [ -f "$BASELINE_DIR/group.baseline" ]; then
        diff "$BASELINE_DIR/group.baseline" /etc/group | grep '^>' | while read -r line; do
            log_event "user" "alert" "Group change: ${line:2}"
        done
    fi
    
    # Check kernel modules
    echo -e "\n[+] Checking for kernel module changes..."
    lsmod > "$BASELINE_DIR/kernel_modules_current.txt"
    if [ -f "$BASELINE_DIR/kernel_modules.txt" ]; then
        diff "$BASELINE_DIR/kernel_modules.txt" "$BASELINE_DIR/kernel_modules_current.txt" | grep '^>' | while read -r line; do
            log_event "kernel" "warning" "Kernel module change: ${line:2}"
        done
    fi
    
    # Check cron jobs
    echo -e "\n[+] Checking for cron job changes..."
    crontab -l > "$BASELINE_DIR/crontab_root_current.txt" 2>/dev/null
    if [ -f "$BASELINE_DIR/crontab_root.txt" ]; then
        diff "$BASELINE_DIR/crontab_root.txt" "$BASELINE_DIR/crontab_root_current.txt" | grep '^>' | while read -r line; do
            log_event "cron" "alert" "Root cron job change: ${line:2}"
        done
    fi
    
    for user in $(cut -f1 -d: /etc/passwd); do
        crontab -u "$user" -l > "$BASELINE_DIR/crontab_${user}_current.txt" 2>/dev/null
        if [ -f "$BASELINE_DIR/crontab_$user.txt" ]; then
            diff "$BASELINE_DIR/crontab_$user.txt" "$BASELINE_DIR/crontab_${user}_current.txt" | grep '^>' | while read -r line; do
                log_event "cron" "alert" "User cron job change ($user): ${line:2}"
            done
        fi
    done
    
    # Check Suricata configuration
    if [ -f "$BASELINE_DIR/suricata_checksum.txt" ]; then
        current_checksum=$(md5sum /etc/suricata/suricata.yaml 2>/dev/null)
        if [ "$current_checksum" != "$(cat $BASELINE_DIR/suricata_checksum.txt)" ]; then
            log_event "suricata" "warning" "Suricata configuration has changed"
        fi
    fi
    
    echo "Deviation check completed. Review $EVENT_LOG for details."
}

# EDR Monitoring Functions
monitor_processes() {
    # Load process rules
    declare -A process_rules
    while IFS=: read -r process severity action; do
        [[ "$process" =~ ^# ]] || [[ -z "$process" ]] && continue
        process_rules["$process"]="$severity:$action"
    done < "$RULES_DIR/process_rules.txt"
    
    # Check processes once
    for process in "${!process_rules[@]}"; do
        if pgrep -x "$process" >/dev/null; then
            IFS=: read -r severity action <<< "${process_rules[$process]}"
            details="Suspicious process detected: $process (Severity: $severity)"
            
            case $action in
                "alert")
                    log_event "process" "$severity" "$details"
                    ;;
                "kill")
                    log_event "process" "$severity" "$details - Process killed"
                    pkill -9 "$process"
                    ;;
                "quarantine")
                    log_event "process" "$severity" "$details - Process quarantined"
                    pkill -9 "$process"
                    ;;
                *)
                    log_event "process" "$severity" "$details"
                    ;;
            esac
            
            # Automated containment if configured
            if [ "$AUTO_CONTAIN" = "true" ]; then
                if [ "$severity" = "critical" ] || 
                   [ "$severity" = "high" && "$CONTAINMENT_LEVEL" != "low" ] ||
                   [ "$CONTAINMENT_LEVEL" = "high" ]; then
                    contain_threat "$severity" "process" "$process"
                fi
            fi
        fi
    done
}

monitor_files() {
    echo "Starting file monitoring with EDR rules..."
    
    # Load file rules
    declare -A file_rules
    while IFS=: read -r path perm_change content_change; do
        [[ "$path" =~ ^# ]] || [[ -z "$path" ]] && continue
        file_rules["$path"]="$perm_change:$content_change"
    done < "$RULES_DIR/file_rules.txt"
    
    # Monitor files
    for path in "${!file_rules[@]}"; do
        IFS=: read -r perm_change content_change <<< "${file_rules[$path]}"
        
        if [ -e "$path" ]; then
            # Check permission changes
            current_perm=$(stat -c "%a" "$path" 2>/dev/null)
            original_perm=$(grep "$path," "$BASELINE_DIR/filesystem.csv" 2>/dev/null | cut -d, -f4)
            
            if [ -n "$original_perm" ] && [ "$current_perm" != "$original_perm" ]; then
                log_event "file" "$perm_change" "Permission change detected: $path (from $original_perm to $current_perm)"
            fi
            
            # Check content changes (simplified)
            if [ -f "$path" ]; then
                current_hash=$(md5sum "$path" | awk '{print $1}' 2>/dev/null)
                original_hash=$(grep "$path," "$BASELINE_DIR/filesystem.csv" 2>/dev/null | cut -d, -f1 | md5sum | awk '{print $1}' 2>/dev/null)
                
                if [ -n "$original_hash" ] && [ "$current_hash" != "$original_hash" ]; then
                    log_event "file" "$content_change" "Content change detected: $path"
                fi
            fi
        fi
    done
}


rotate_logs() {
    # Rotate logs if they exceed maximum size
    find "$LOG_DIR" -type f -name "*.log" -size +100M -exec gzip {} \;
    
    # Delete old logs after 30 days
    find "$LOG_DIR" -type f -name "*.gz" -mtime +30 -delete
    
    # Compress event log daily
    if [ -f "$EVENT_LOG" ]; then
        local log_date=$(date -d "yesterday" +%Y%m%d)
        gzip -c "$EVENT_LOG" > "${LOG_DIR}/edr_events_${log_date}.log.gz"
        > "$EVENT_LOG"  # Truncate current log file
    fi
}

# Scanning Functions
scan_with_clamav() {
    local path=$1
    clamscan --infected --recursive --verbose --no-summary "$path" 2>&1
}

scan_with_maldet() {
    local path=$1
    /usr/local/sbin/maldet --scan "$path" 2>&1
}

scan_with_suricata() {
    local path=$1
    local suricata_log="${SURICATA_LOGS}/scan_$(date +%Y%m%d%H%M%S).log"
    
    # Run Suricata in pcap processing mode
    suricata -r "$path" -l "$SURICATA_LOGS" > "$suricata_log" 2>&1
    
    # Check for alerts
    if grep -q "alert" "${SURICATA_LOGS}/fast.log"; then
        echo "Suricata alerts detected in scan:"
        grep "alert" "${SURICATA_LOGS}/fast.log"
        return 1
    else
        echo "No Suricata alerts detected"
        return 0
    fi
}

check_file_signatures() {
    local file_path=$1
    local file_hash=$(md5sum "$file_path" | awk '{print $1}' 2>/dev/null)
    
    if [ -z "$file_hash" ]; then
        echo "Error: Could not calculate hash"
        return 1
    fi
    
    while IFS= read -r line; do
        if [[ ! "$line" =~ ^# ]] && [[ "$line" =~ "$file_hash:" ]]; then
            echo "${line#*:}"
            return 0
        fi
    done < "$MALWARE_SIGNATURES"
    
    echo "Clean"
}

monitor_suricata() {
    if [ "$SURICATA_LIVE_MONITOR" != "true" ]; then
        log_event "Suricata" "info" "Live monitoring disabled in config"
        return
    fi

    if [ ! -f "$SURICATA_EVE_LOG" ]; then
        log_event "Suricata" "error" "Eve.json log not found at $SURICATA_EVE_LOG"
        return
    fi

    log_event "Suricata" "info" "Starting live Suricata monitoring"
    
    # Create named pipe for efficient tailing
    local pipe_path="${TEMP_DIR}/suricata_pipe"
    mkfifo "$pipe_path"
    
    # Start tail process in background
    tail -F "$SURICATA_EVE_LOG" > "$pipe_path" &
    local tail_pid=$!
    
    # Main processing loop
    while read -r line; do
        # Parse JSON event
        local event_type=$(echo "$line" | jq -r '.event_type')
        local alert_severity=$(echo "$line" | jq -r '.alert.severity // 0')
        
        # Process only alert events meeting threshold
        if [ "$event_type" = "alert" ] && [ "$alert_severity" -ge "$SURICATA_ALERT_THRESHOLD" ]; then
            local alert_data=$(echo "$line" | jq -c '{
                timestamp: .timestamp,
                src_ip: .src_ip,
                dest_ip: .dest_ip,
                proto: .proto,
                signature: .alert.signature,
                severity: .alert.severity,
                category: .alert.category,
                action: .alert.action
            }')
            
            log_event "Suricata" "high" "Alert detected: $alert_data"
            
            # Take automated action for critical alerts
            if [ "$alert_severity" -ge 3 ]; then
                local src_ip=$(echo "$line" | jq -r '.src_ip')
                contain_threat "high" "network" "$src_ip"
            fi
        fi
    done < "$pipe_path"
    
    # Cleanup
    kill "$tail_pid" 2>/dev/null
    rm -f "$pipe_path"
}

#######################################
### Start Monitoring in Background
#######################################
# Add to your main initialization:
start_suricata_monitor() {
    if [ "$SURICATA_LIVE_MONITOR" != "true" ]; then
        return
    fi
    
    tail -F "$SURICATA_EVE_LOG" | while read -r line; do
        local alert=$(echo "$line" | jq -r 'select(.event_type == "alert")')
        if [ -n "$alert" ]; then
            local severity=$(echo "$alert" | jq -r '.alert.severity')
            if [ "$severity" -ge "$SURICATA_ALERT_THRESHOLD" ]; then
                local signature=$(echo "$alert" | jq -r '.alert.signature')
                local src_ip=$(echo "$alert" | jq -r '.src_ip')
                local dest_ip=$(echo "$alert" | jq -r '.dest_ip')
                
                log_threat "SURICATA_ALERT" "$signature" "$src_ip -> $dest_ip" "$severity"
            fi
        fi
    done
}

#######################################
### Stop Monitoring Function
#######################################
stop_suricata_monitor() {
    if [ -n "$SURICATA_MONITOR_PID" ]; then
        kill "$SURICATA_MONITOR_PID" 2>/dev/null
        log_event "Suricata" "info" "Stopped live monitor (PID: $SURICATA_MONITOR_PID)"
    fi
}

scan_directory() {
    local path=$1
    local scan_type=$2
    local infected_files=()
    
    case $scan_type in
        clamav)
            echo "Running ClamAV scan on $path"
            scan_with_clamav "$path"
            ;;
        maldet)
            echo "Running Maldet scan on $path"
            scan_with_maldet "$path"
            ;;
        signature)
            echo "Running signature scan on $path"
            while IFS= read -r -d '' file; do
                result=$(check_file_signatures "$file")
                if [ "$result" != "Clean" ]; then
                    echo "Found infected file: $file (Signature: $result)"
                    infected_files+=("$file")
                    
                    # Quarantine the file
                    quarantine_path="${file/$path/$QUARANTINE_DIR}"
                    mkdir -p "$(dirname "$quarantine_path")"
                    mv "$file" "$quarantine_path"
                    
                    log_event "quarantine" "high" "File quarantined: $file (Signature: $result)"
                    
                    # Check threat intelligence if configured
                    if [ -n "${THREAT_INTEL_API}" ]; then
                        threat_info=$(check_threat_intel "$file_hash" "hash")
                        if [ -n "$threat_info" ]; then
                            log_event "threat" "critical" "Known malicious file detected: $file (Threat: $threat_info)"
                        fi
                    fi
                fi
            done < <(find "$path" -type f -print0)
            
            if [ ${#infected_files[@]} -eq 0 ]; then
                echo "No infected files found"
            else
                echo "Quarantined ${#infected_files[@]} files"
            fi
            ;;
        suricata)
            echo "Running Suricata IDS scan on $path"
            scan_with_suricata "$path"
            ;;
        *)
            echo "Invalid scan type. Available options: clamav, maldet, signature, suricata"
            return 1
            ;;
    esac
}

# Quarantine Management
list_quarantine() {
    find "$QUARANTINE_DIR" -type f
}

restore_file() {
    local filename=$1
    local original_path="${filename/$QUARANTINE_DIR/}"
    
    if [ ! -f "$filename" ]; then
        echo "Error: File not found in quarantine"
        return 1
    fi
    
    mkdir -p "$(dirname "$original_path")"
    mv "$filename" "$original_path"
    echo "Restored $filename to $original_path"
    log_event "quarantine" "info" "File restored from quarantine: $filename to $original_path"
}

delete_file() {
    local filename=$1
    
    if [ ! -f "$filename" ]; then
        echo "Error: File not found in quarantine"
        return 1
    fi
    
    rm -f "$filename"
    echo "Permanently deleted $filename"
    log_event "quarantine" "info" "File permanently deleted from quarantine: $filename"
}

# Network Functions
check_malicious_connections() {
    local malicious_ips=()
    
    if [ -f "$MALICIOUS_IPS" ]; then
        while IFS= read -r line; do
            [[ "$line" =~ ^# ]] || [[ -z "$line" ]] || malicious_ips+=("$line")
        done < "$MALICIOUS_IPS"
    fi
    
    echo "Checking for malicious connections..."
    netstat -tunap | awk '/ESTABLISHED/ {print $5, $7}' | while read -r raddr pid_proc; do
        ip=$(echo "$raddr" | cut -d: -f1)
        pid=$(echo "$pid_proc" | cut -d'/' -f1)
        
        for malicious_ip in "${malicious_ips[@]}"; do
            if [ "$ip" == "$malicious_ip" ]; then
                process=$(ps -p "$pid" -o comm= 2>/dev/null || echo "Unknown")
                details="Malicious connection detected: PID: $pid, Process: $process, Remote IP: $ip, Port: $(echo "$raddr" | cut -d: -f2)"
                log_event "network" "critical" "$details"
                echo "$details"
                
                # Check threat intelligence if configured
                if [ -n "${THREAT_INTEL_API}" ]; then
                    threat_info=$(check_threat_intel "$ip" "ip")
                    if [ -n "$threat_info" ]; then
                        log_event "threat" "critical" "Known malicious connection detected: $ip (Threat: $threat_info)"
                        contain_threat "critical" "network" "$ip"
                    fi
                fi
            fi
        done
    done
    
    # Check Suricata alerts for malicious connections
    if [ -f "${SURICATA_LOGS}/fast.log" ]; then
        grep "ET.*MALWARE" "${SURICATA_LOGS}/fast.log" | while read -r alert; do
            log_event "suricata" "high" "Suricata malware alert: $alert"
            echo "Suricata malware alert: $alert"
        done
    fi
}

check_abnormal_ports() {
    echo "Checking for abnormal listening ports..."
    netstat -tunlp | awk '/LISTEN/ {print $4, $7}' | while read -r laddr pid_proc; do
        port=$(echo "$laddr" | rev | cut -d: -f1 | rev)
        pid=$(echo "$pid_proc" | cut -d'/' -f1)
        
        # Common ports to ignore
        case $port in
            20|21|22|23|25|53|80|110|143|443|465|587|993|995|3306|3389)
                continue
                ;;
        esac
        
        if [ "$port" -gt 1024 ]; then
            process=$(ps -p "$pid" -o comm= 2>/dev/null || echo "Unknown")
            details="Abnormal port detected: Port: $port, PID: $pid, Process: $process"
            log_event "network" "warning" "$details"
            echo "$details"
        fi
    done
}

# System Monitoring
check_abnormal_processes() {
    echo "Checking for abnormal processes..."
    ps -eo pid,%cpu,%mem,comm --sort=-%cpu | awk 'NR>1 && ($2 > 80 || $3 > 30) {
        details="High resource usage: PID: "$1", CPU: "$2"%, MEM: "$3"%, Process: "$4
        log_event "process", "warning", details
        printf "%s\n\n", details
    }'
    
    echo "Checking for hidden/deleted executables..."
    find /proc/[0-9]*/exe -type l -exec ls -l {} + 2>/dev/null | grep '(deleted)' | while read -r line; do
        pid=$(echo "$line" | awk -F'/' '{print $3}')
        process=$(ps -p "$pid" -o comm= 2>/dev/null || echo "Unknown")
        details="Deleted executable still running: PID: $pid, Process: $process, Executable: $(echo "$line" | awk '{print $11}')"
        log_event "process" "alert" "$details"
        echo "$details"
    done
}

# Vulnerability Scanning
vulnerability_scan() {
    echo "Running vulnerability scan..."
    
    echo -e "\nWorld-writable files:"
    find / -xdev -type f -perm -0002 2>/dev/null | while read -r file; do
        log_event "vulnerability" "medium" "World-writable file: $file"
        echo "$file"
    done
    
    echo -e "\nSUID/SGID files:"
    find / -xdev -type f -perm -4000 -o -perm -2000 2>/dev/null | while read -r file; do
        log_event "vulnerability" "medium" "SUID/SGID file: $file"
        echo "$file"
    done
    
    echo -e "\nPending system updates:"
    if command -v apt-get &>/dev/null; then
        updates=$(apt list --upgradable 2>/dev/null)
        if [ -n "$updates" ]; then
            log_event "vulnerability" "high" "Pending system updates available"
            echo "$updates"
        fi
    elif command -v yum &>/dev/null; then
        updates=$(yum list updates 2>/dev/null)
        if [ -n "$updates" ]; then
            log_event "vulnerability" "high" "Pending system updates available"
            echo "$updates"
        fi
    else
        echo "Could not determine package manager"
    fi
    
    # Check Suricata rules freshness
    if [ -f "$SURICATA_DIR/last_update" ]; then
        local last_update=$(date -r "$SURICATA_DIR/last_update" +%s)
        local current_time=$(date +%s)
        
        if (( current_time - last_update > 604800 )); then # 7 days
            log_event "vulnerability" "high" "Suricata rules are outdated (last updated: $(date -d @$last_update))"
            echo "Suricata rules are outdated (last updated: $(date -d @$last_update))"
        fi
    fi
}

# Threat Hunting
hunt_suspicious_activity() {
    echo "Hunting for suspicious activity..."
    
    # Check for SSH brute force attempts
    echo -e "\nSSH login attempts:"
    grep "Failed password" /var/log/auth.log 2>/dev/null || grep "Failed password" /var/log/secure 2>/dev/null | \
    awk '{print $1,$2,$3,$9,$11}' | sort | uniq -c | sort -nr | while read -r line; do
        count=$(echo "$line" | awk '{print $1}')
        ip=$(echo "$line" | awk '{print $5}')
        if [ "$count" -gt 5 ]; then
            details="Possible SSH brute force attempt from $ip ($count attempts)"
            log_event "threat" "high" "$details"
            echo "$details"
            
            # Check threat intelligence if configured
            if [ -n "${THREAT_INTEL_API}" ]; then
                threat_info=$(check_threat_intel "$ip" "ip")
                if [ -n "$threat_info" ]; then
                    log_event "threat" "critical" "Known malicious SSH attempt from: $ip (Threat: $threat_info)"
                fi
            fi
        fi
    done
    
    # Check for suspicious commands in history
    echo -e "\nSuspicious commands in bash history:"
    for user in $(cut -f1 -d: /etc/passwd); do
        home=$(eval echo "~$user")
        if [ -f "$home/.bash_history" ]; then
            grep -E "(wget|curl|chmod|chown|ssh|scp|nc|socat|telnet|ftp|lynx|whois) " "$home/.bash_history" | \
            while read -r cmd; do
                details="Suspicious command in $user's history: $cmd"
                log_event "threat" "medium" "$details"
                echo "$details"
            done
        fi
    done
    
    # Check for unusual cron jobs
    echo -e "\nUnusual cron jobs:"
    find /etc/cron* /var/spool/cron -type f -exec grep -vE "^#" {} \; | \
    grep -E "(wget|curl|chmod|chown|ssh|scp|nc|socat|telnet|ftp|lynx|whois) " | \
    while read -r line; do
        details="Suspicious cron job: $line"
        log_event "threat" "high" "$details"
        echo "$details"
    done
    
    # Check Suricata alerts
    echo -e "\nRecent Suricata alerts:"
    if [ -f "${SURICATA_LOGS}/fast.log" ]; then
        grep "alert" "${SURICATA_LOGS}/fast.log" | tail -n 10 | while read -r alert; do
            details="Suricata alert: $alert"
            log_event "suricata" "medium" "$details"
            echo "$details"
        done
    fi
    
    # Perform behavioral analysis
    analyze_behavior
}

# Enterprise EDR Main Execution
enterprise_edr_scan() {
    # Prevent multiple runs
    if [ -e "${LOCK_FILE}" ]; then
        pid=$(cat "${LOCK_FILE}")
        if ps -p "${pid}" > /dev/null; then
            exit 0
        fi
    fi
    echo $$ > "${LOCK_FILE}"
    
    # Initialize
    current_date=$(date +%Y%m%d)
    
    # Start enterprise scan
    log_event "INFO" "Starting enterprise EDR scan (v${VERSION})"
    
    # Behavioral analysis
    analyze_behavior
    
    # Threat detection modules
    check_malicious_connections
    check_abnormal_ports
    check_abnormal_processes
    hunt_suspicious_activity
    
    # Compliance reporting
    generate_compliance_report
    
    # Cleanup
    rm -rf "${TEMP_DIR}"
    rm -f "${LOCK_FILE}"
    
    log_event "INFO" "Enterprise EDR scan completed"
}

# Main function
main() {
    init_directories
    
    if [ $# -eq 0 ]; then
        echo -e "${BLUE}LinuxAV-Solutions Command Line Tool with Enterprise EDR${NC}"
        echo -e "Version: ${GREEN}$VERSION${NC}"
        echo -e "Suricata IDS/IPS: $(suricata_status)"
        echo "Usage: $0 [OPTION]..."
        echo
        echo "Options:"
        echo "  --status                  Show system security status"
        echo "  --scan PATH [--type TYPE] Scan a directory (types: clamav, maldet, signature, suricata)"
        echo "  --quarantine [--list]     List quarantined files"
        echo "  --quarantine --restore FILE  Restore a file from quarantine"
        echo "  --quarantine --delete FILE    Permanently delete a quarantined file"
        echo "  --network-connections     Check for malicious network connections"
        echo "  --network-ports           Check for abnormal listening ports"
        echo "  --processes               Check for abnormal processes"
        echo "  --vulnerability           Run vulnerability scan"
        echo "  --edr-baseline            Create system baseline for EDR"
        echo "  --edr-deviations          Check for system deviations from baseline"
        echo "  --edr-monitor-processes   Start EDR process monitoring"
        echo "  --edr-monitor-files       Run EDR file monitoring"
        echo "  --edr-threat-hunt         Perform threat hunting"
        echo "  --edr-events [--last N]   Show EDR events (last N events)"
        echo "  --enterprise-scan         Run comprehensive enterprise EDR scan"
        echo "  --help                    Show this help message"
        return 1
    fi
    
    while [ $# -gt 0 ]; do
        case $1 in
        start)
            start_daemon
            ;;
        stop)
            stop_daemon
            ;;
        status)
            status_daemon
            ;;
        restart)
            stop_daemon
            sleep 2
            start_daemon
            ;;
        --daemon)
            # Daemon mode - run main loop
            daemon_loop
            ;;
        *)
            # Original CLI functionality
            init_directories
            
            if [ $# -eq 0 ]; then
                echo "Usage: $0 [start|stop|restart|status] for daemon control"
                echo "Or use original CLI options for manual operations"
                return 1
            fi
            --status)
                echo -e "${BLUE}=== System Security Status ===${NC}"
                echo -e "SELinux Status: $(se_status)"
                echo -e "Firewall Status: $(firewall_status)"
                echo -e "Network Manager Status: $(network_manager_status)"
                echo -e "ClamAV Status: $(clam_status)"
                echo -e "Fail2Ban Status: $(fail2ban_status)"
                echo -e "Suricata Status: $(suricata_status)"
                echo -e "Quarantine Items: $(num_quarantine)"
                echo -e "App Disk Usage: $(app_disk_usage)"
                echo -e "Enterprise EDR Version: $VERSION"
                echo -e "Central Management: ${CENTRAL_MGMT_SERVER:-Not configured}"
                shift
                ;;
            --scan)
                if [ -z "$2" ]; then
                    echo -e "${RED}Error: No path specified for scan${NC}"
                    return 1
                fi
                path=$2
                shift 2
                
                scan_type="signature"
                if [ "$1" == "--type" ]; then
                    scan_type=$2
                    shift 2
                fi
                
                scan_directory "$path" "$scan_type"
                ;;
            --quarantine)
                case $2 in
                    --list)
                        echo -e "${BLUE}Quarantined files:${NC}"
                        list_quarantine
                        shift 2
                        ;;
                    --restore)
                        if [ -z "$3" ]; then
                            echo -e "${RED}Error: No file specified for restore${NC}"
                            return 1
                        fi
                        restore_file "$3"
                        shift 3
                        ;;
                    --delete)
                        if [ -z "$3" ]; then
                            echo -e "${RED}Error: No file specified for deletion${NC}"
                            return 1
                        fi
                        delete_file "$3"
                        shift 3
                        ;;
                    *)
                        echo -e "${BLUE}Quarantined files:${NC}"
                        list_quarantine
                        shift
                        ;;
                esac
                ;;
            --network-connections)
                check_malicious_connections
                shift
                ;;
            --network-ports)
                check_abnormal_ports
                shift
                ;;
            --processes)
                check_abnormal_processes
                shift
                ;;
            --vulnerability)
                vulnerability_scan
                shift
                ;;
            --edr-baseline)
                create_baseline
                shift
                ;;
            --edr-deviations)
                check_deviations
                shift
                ;;
            --edr-monitor-processes)
                monitor_processes
                shift
                ;;
            --edr-monitor-files)
                monitor_files
                shift
                ;;
            --edr-threat-hunt)
                hunt_suspicious_activity
                shift
                ;;
            --edr-events)
                if [ "$2" == "--last" ]; then
                    count=$3
                    echo -e "${BLUE}=== Last $count EDR Events ===${NC}"
                    tail -n "$count" "$EVENT_LOG" | awk -F, '{printf "[%s] %-7s %s\n", $1, $2, $3}'
                    shift 3
                else
                    echo -e "${BLUE}=== EDR Events ===${NC}"
                    cat "$EVENT_LOG" | awk -F, '{printf "[%s] %-7s %s\n", $1, $2, $3}'
                    shift
                fi
                ;;
            --enterprise-scan)
                enterprise_edr_scan
                shift
                ;;
            --help)
                main
                return 0
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                return 1
                ;;
        esac
    done
}

# Run the script
main "$@"