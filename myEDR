#!/bin/bash

# LinuxAV-Solutions Command Line Tool with Enterprise EDR Capabilities
# Version: 4.0
# Features: Centralized Management, Threat Intelligence Integration, Behavioral Analysis, 
#           Automated Response, Compliance Reporting, SIEM Integration, Suricata IDS/IPS

## Global Configuration
USERNAME=$(whoami)
APPDIR="/home/$USER/.myEDR"
LOG_DIR="$APPDIR/Log"
QUARANTINE_DIR="$APPDIR/Quarantine"
SIGNATURES_DIR="$APPDIR/Signatures"
MALWARE_SIGNATURES="$SIGNATURES_DIR/malware_signatures.txt"
MALICIOUS_IPS="$SIGNATURES_DIR/malicious_ips.txt"
EDR_DIR="$APPDIR/EDR"
EVENT_LOG="$EDR_DIR/events.log"
BASELINE_DIR="$EDR_DIR/baseline"
CONFIG_DIR="$EDR_DIR/config"
RULES_DIR="$EDR_DIR/rules"
REPORT_DIR="$APPDIR/Reports"
SURICATA_DIR="$APPDIR/Suricata"
SURICATA_RULES="$SURICATA_DIR/rules"
SURICATA_LOGS="$SURICATA_DIR/logs"

## Enterprise EDR Configuration
CONFIG_FILE="${CONFIG_DIR}/edr.conf"
TEMP_DIR="/tmp/edr_$(date +%s)"
LOCK_FILE="/var/run/edr.lock"
VERSION="4.0.0"

## Enterprise Features
CENTRAL_MGMT_SERVER="edr-mgmt.corporate.com"
SIEM_SERVER="siem.corporate.com:514"
THREAT_INTEL_API="https://ti.corporate.com/api/v1/check"
MACHINE_ID=$(cat /etc/machine-id 2>/dev/null || hostname)
DEPLOYMENT_GROUP=$(cat ${CONFIG_DIR}/deployment_group 2>/dev/null || echo "default")

## Colors for reporting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Initialize directories and enterprise environment
init_directories() {
    mkdir -p "$APPDIR" "$LOG_DIR" "$QUARANTINE_DIR" "$SIGNATURES_DIR" "$EDR_DIR" \
             "$BASELINE_DIR" "$CONFIG_DIR" "$RULES_DIR" "$REPORT_DIR" \
             "$SURICATA_DIR" "$SURICATA_RULES" "$SURICATA_LOGS"
    
    # Create default signature database if not exists
    if [ ! -f "$MALWARE_SIGNATURES" ]; then
        echo "# Malware signatures database" > "$MALWARE_SIGNATURES"
        echo "d41d8cd98f00b204e9800998ecf8427e:TEST_SIGNATURE" >> "$MALWARE_SIGNATURES"
    fi
    
    # Create default malicious IPs list if not exists
    if [ ! -f "$MALICIOUS_IPS" ]; then
        echo "# Known malicious IP addresses" > "$MALICIOUS_IPS"
        echo "# Add one IP per line" >> "$MALICIOUS_IPS"
        echo "123.123.123.123" >> "$MALICIOUS_IPS"
    fi
    
    # Create default EDR rules if not exists
    if [ ! -f "$RULES_DIR/process_rules.txt" ]; then
        echo "# EDR Process Monitoring Rules" > "$RULES_DIR/process_rules.txt"
        echo "# Format: process_name:severity:action" >> "$RULES_DIR/process_rules.txt"
        echo "nc:high:alert" >> "$RULES_DIR/process_rules.txt"
        echo "socat:high:alert" >> "$RULES_DIR/process_rules.txt"
        echo "miner:critical:kill" >> "$RULES_DIR/process_rules.txt"
    fi
    
    if [ ! -f "$RULES_DIR/file_rules.txt" ]; then
        echo "# EDR File Monitoring Rules" > "$RULES_DIR/file_rules.txt"
        echo "# Format: path:permission_changes:content_changes" >> "$RULES_DIR/file_rules.txt"
        echo "/etc/passwd:alert:critical" >> "$RULES_DIR/file_rules.txt"
        echo "/etc/shadow:alert:critical" >> "$RULES_DIR/file_rules.txt"
        echo "/root/.ssh/:critical:critical" >> "$RULES_DIR/file_rules.txt"
    fi
    
    # Initialize event log
    if [ ! -f "$EVENT_LOG" ]; then
        echo "# LinuxAV-Solutions EDR Event Log" > "$EVENT_LOG"
        echo "# Timestamp,EventType,Severity,Details" >> "$EVENT_LOG"
    fi
    
    # Initialize Suricata rules if not exists
    if [ ! -f "$SURICATA_RULES/local.rules" ]; then
        echo "# Suricata local rules" > "$SURICATA_RULES/local.rules"
        echo 'alert ip any any -> any any (msg:"ET POLICY Suspicious inbound to MySQL port 3306"; flow:to_server,established; dport:3306; threshold: type limit, track by_src, count 1, seconds 60; reference:url,doc.emergingthreats.net/2001976; classtype:attempted-recon; sid:2001976; rev:9;)' >> "$SURICATA_RULES/local.rules"
    fi
    
    # Initialize enterprise environment
    init_enterprise
}

## Initialize Enterprise Environment
init_enterprise() {
    # Create necessary directories
    mkdir -p ${CONFIG_DIR} /var/log/edr /var/lib/edr/{quarantine,artifacts} \
             /var/run/edr ${TEMP_DIR}
    
    # Load configuration
    if [ -f "${CONFIG_FILE}" ]; then
        source "${CONFIG_FILE}"
    else
        generate_enterprise_config
    fi
    
    # Set up logging
    exec 2>>"${LOG_DIR}/edr_error.log"
    
    # Check for central configuration updates
    check_config_updates
    
    # Initialize Suricata if installed
    if command -v suricata &>/dev/null; then
        init_suricata
    fi
}

## Initialize Suricata IDS/IPS
init_suricata() {
    # Check if Suricata is running
    if ! pgrep -x "suricata" >/dev/null; then
        # Start Suricata in IDS mode
        suricata -c /etc/suricata/suricata.yaml -i $(ip route get 1 | awk '{print $5;exit}') --user suricata --group suricata -D
        
        if [ $? -eq 0 ]; then
            log_event "INFO" "Suricata IDS/IPS started successfully"
        else
            log_event "ERROR" "Failed to start Suricata IDS/IPS"
        fi
    fi
    
    # Update Suricata rules periodically
    update_suricata_rules
}

update_suricata_rules() {
    # Check if rule update is needed (once per day)
    local last_update=0
    if [ -f "$SURICATA_DIR/last_update" ]; then
        last_update=$(date -r "$SURICATA_DIR/last_update" +%s)
    fi
    local current_time=$(date +%s)
    
    if (( current_time - last_update > 86400 )); then
        log_event "INFO" "Updating Suricata rules"
        
        # Pull ET Open rules
        if curl -s https://rules.emergingthreats.net/open/suricata-6.0.0/emerging.rules.tar.gz | \
           tar xz -C "$SURICATA_RULES"; then
            touch "$SURICATA_DIR/last_update"
            log_event "INFO" "Suricata rules updated successfully"
            
            # Reload Suricata if running
            if pgrep -x "suricata" >/dev/null; then
                suricatasc -c reload-rules
            fi
        else
            log_event "ERROR" "Failed to update Suricata rules"
        fi
    fi
}

## Enterprise Configuration Generator
generate_enterprise_config() {
    cat > "${CONFIG_FILE}" <<EOF
# Enterprise EDR Configuration
# Auto-generated on $(date)

# Directory Configuration
LOG_DIR="/var/log/edr"
REPORT_DIR="/var/reports/edr"
QUARANTINE_DIR="/var/lib/edr/quarantine"
ARTIFACT_DIR="/var/lib/edr/artifacts"

# Network Configuration
CENTRAL_MGMT_SERVER="edr-mgmt.corporate.com"
SIEM_SERVER="siem.corporate.com:514"
THREAT_INTEL_API="https://ti.corporate.com/api/v1/check"

# Scanning Configuration
SCAN_DIRS="/home /etc /bin /usr/bin /usr/sbin /opt"
YARA_RULES_DIR="/etc/edr/yara_rules"
SIGNATURE_DB="/etc/edr/signatures.db"

# Response Configuration
AUTO_CONTAINMENT_LEVEL="high"
NETWORK_ISOLATION_THRESHOLD=3

# Monitoring Configuration
ENABLE_BEHAVIORAL_MONITORING=true
ENABLE_REALTIME_PROCESS_MONITORING=true
ENABLE_FILE_INTEGRITY_MONITORING=true
ENABLE_SURICATA=true

# Notification Configuration
SECURITY_TEAM_EMAIL="security-team@corporate.com"
INCIDENT_RESPONSE_PAGER="ir-team@corporate.com"

# Compliance Configuration
COMPLIANCE_STANDARD="PCI DSS 3.2"
REQUIRED_CHECKS="file_integrity,user_accounts,firewall_rules,audit_config"

# Advanced Configuration
MAX_LOG_SIZE="100M"
LOG_RETENTION_DAYS=90
EOF

    chmod 600 "${CONFIG_FILE}"
}

## Centralized Management Functions
check_config_updates() {
    local last_update=$(stat -c %Y "${CONFIG_FILE}" 2>/dev/null || echo 0)
    local current_time=$(date +%s)
    
    if (( current_time - last_update > 3600 )); then
        log_event "INFO" "Checking for configuration updates from central server"
        
        if curl -s --connect-timeout 10 --cert ${CONFIG_DIR}/client.pem \
           "https://${CENTRAL_MGMT_SERVER}/config/${MACHINE_ID}" -o "${TEMP_DIR}/new_config"; then
            
            if validate_config "${TEMP_DIR}/new_config"; then
                mv "${TEMP_DIR}/new_config" "${CONFIG_FILE}"
                log_event "INFO" "Configuration updated from central server"
                source "${CONFIG_FILE}"
            fi
        fi
    fi
}

validate_config() {
    local config_file=$1
    # Basic validation - ensure it's a proper bash file
    return $(bash -n "${config_file}" 2>/dev/null)
}

## Enhanced Logging Framework
log_event() {
    local severity=$1
    local message=$2
    local timestamp=$(date --iso-8601=seconds)
    local log_entry="[${timestamp}] [${severity}] ${message}"
    
    # Local logging
    echo "${log_entry}" >> "${LOG_DIR}/edr_${current_date}.log"
    echo "${timestamp},${severity},${message}" >> "${EVENT_LOG}"
    
    # SIEM integration (if configured)
    if [ -n "${SIEM_SERVER}" ]; then
        echo "<14>${timestamp} ${HOSTNAME} EDR[$$]: ${severity}: ${message}" | \
            nc -w 2 -u "${SIEM_SERVER}" 2>/dev/null
    fi
    
    # Central logging (if configured)
    if [ -n "${CENTRAL_MGMT_SERVER}" ]; then
        curl -s -X POST --connect-timeout 3 --cert ${CONFIG_DIR}/client.pem \
             -d "host=${MACHINE_ID}&group=${DEPLOYMENT_GROUP}&severity=${severity}&message=${message}" \
             "https://${CENTRAL_MGMT_SERVER}/logs" >/dev/null
    fi
}

## Threat Intelligence Integration
check_threat_intel() {
    local indicator=$1
    local indicator_type=$2  # ip, hash, domain
    
    if [ -z "${THREAT_INTEL_API}" ]; then
        return
    fi
    
    local response=$(curl -s --connect-timeout 5 --cert ${CONFIG_DIR}/client.pem \
        "${THREAT_INTEL_API}/${indicator_type}/${indicator}")
    
    if echo "${response}" | jq -e '.match == true' >/dev/null; then
        local threat_level=$(echo "${response}" | jq -r '.threat_level')
        local threat_name=$(echo "${response}" | jq -r '.threat_name')
        echo "${threat_level} ${threat_name}"
    fi
}

## Behavioral Analysis Engine
analyze_behavior() {
    # Capture process tree snapshot
    ps -eo pid,ppid,user,cmd --forest > "${TEMP_DIR}/process_tree.txt"
    
    # Network connections analysis
    netstat -tulnpe > "${TEMP_DIR}/network_connections.txt"
    
    # File activity analysis
    lsof +L1 > "${TEMP_DIR}/deleted_files.txt"
    
    # Suricata alerts analysis
    if [ -f "${SURICATA_LOGS}/fast.log" ]; then
        cp "${SURICATA_LOGS}/fast.log" "${TEMP_DIR}/suricata_alerts.txt"
    fi
    
    # Send to central analysis (async) if configured
    if [ -n "${CENTRAL_MGMT_SERVER}" ]; then
        (tar czf - -C "${TEMP_DIR}" process_tree.txt network_connections.txt deleted_files.txt suricata_alerts.txt 2>/dev/null | \
         curl -s -X POST --connect-timeout 10 --cert ${CONFIG_DIR}/client.pem \
         --data-binary @- "https://${CENTRAL_MGMT_SERVER}/behavior/${MACHINE_ID}" >/dev/null) &
    fi
}

## Enhanced Response Framework
contain_threat() {
    local threat_level=$1
    local threat_type=$2
    local indicator=$3
    
    case "${threat_level}" in
        "critical")
            # Immediate isolation
            isolate_host
            quarantine_artifacts "${threat_type}" "${indicator}"
            notify_security_team "CRITICAL" "Contained critical ${threat_type} threat: ${indicator}"
            ;;
        "high")
            # Block network activity
            block_network "${threat_type}" "${indicator}"
            quarantine_artifacts "${threat_type}" "${indicator}"
            notify_security_team "HIGH" "Contained high ${threat_type} threat: ${indicator}"
            ;;
        *)
            # Log and alert
            log_event "WARNING" "Detected ${threat_type} threat: ${indicator}"
            notify_security_team "MEDIUM" "Detected ${threat_type} threat: ${indicator}"
            ;;
    esac
}

isolate_host() {
    log_event "CRITICAL" "Initiating host isolation procedures"
    
    # Network isolation
    iptables -P INPUT DROP
    iptables -P OUTPUT DROP
    iptables -P FORWARD DROP
    
    # Process containment
    pkill -STOP -f "${malicious_process_patterns}"
    
    # Central alert
    if [ -n "${CENTRAL_MGMT_SERVER}" ]; then
        curl -s -X POST --connect-timeout 5 --cert ${CONFIG_DIR}/client.pem \
             -d "host=${MACHINE_ID}&action=isolated" \
             "https://${CENTRAL_MGMT_SERVER}/response" >/dev/null
    fi
}

block_network() {
    local threat_type=$1
    local indicator=$2
    
    case "$threat_type" in
        "ip")
            iptables -A INPUT -s "$indicator" -j DROP
            iptables -A OUTPUT -d "$indicator" -j DROP
            log_event "NETWORK" "Blocked network traffic to/from $indicator"
            ;;
        "port")
            iptables -A INPUT -p tcp --dport "$indicator" -j DROP
            iptables -A OUTPUT -p tcp --dport "$indicator" -j DROP
            log_event "NETWORK" "Blocked traffic on port $indicator"
            ;;
        "domain")
            # Add to /etc/hosts to null route
            echo "0.0.0.0 $indicator" >> /etc/hosts
            log_event "NETWORK" "Null routed domain $indicator"
            ;;
    esac
}

## Compliance Reporting
generate_compliance_report() {
    local report_file="${REPORT_DIR}/compliance_$(date +%Y%m%d).json"
    
    # Collect compliance data
    local compliance_data=$(cat <<EOF
{
    "timestamp": "$(date --iso-8601=seconds)",
    "host": "${MACHINE_ID}",
    "group": "${DEPLOYMENT_GROUP}",
    "checks": {
        "file_integrity": $(check_file_integrity),
        "user_accounts": $(check_user_accounts),
        "firewall_rules": $(check_firewall),
        "audit_config": $(check_audit_config),
        "suricata_status": $(check_suricata_status)
    }
}
EOF
    )
    
    echo "${compliance_data}" > "${report_file}"
    
    # Generate visual report
    generate_visual_report "${report_file}"
    
    # Upload to central server if configured
    if [ -n "${CENTRAL_MGMT_SERVER}" ]; then
        curl -s -X POST --connect-timeout 10 --cert ${CONFIG_DIR}/client.pem \
             -H "Content-Type: application/json" \
             --data-binary @"${report_file}" \
             "https://${CENTRAL_MGMT_SERVER}/compliance" >/dev/null
    fi
}

## Visual Reporting with termgraph
generate_visual_report() {
    local report_file=$1
    local visual_report="${REPORT_DIR}/compliance_$(date +%Y%m%d)_visual.txt"
    
    # Extract data for visualization
    local file_integrity=$(jq '.checks.file_integrity.score' "$report_file")
    local user_accounts=$(jq '.checks.user_accounts.score' "$report_file")
    local firewall=$(jq '.checks.firewall_rules.score' "$report_file")
    local audit=$(jq '.checks.audit_config.score' "$report_file")
    local suricata=$(jq '.checks.suricata_status.score' "$report_file")
    
    # Create termgraph data
    cat > "${TEMP_DIR}/compliance.dat" <<EOF
# Compliance Scores
File Integrity,${file_integrity}
User Accounts,${user_accounts}
Firewall,${firewall}
Audit Config,${audit}
Suricata,${suricata}
EOF
    
    # Generate visual report
    echo -e "\n${BLUE}=== COMPLIANCE REPORT ===${NC}\n" > "$visual_report"
    termgraph "${TEMP_DIR}/compliance.dat" --color {green,yellow,red} >> "$visual_report"
    
    # Add recommendations
    echo -e "\n${YELLOW}=== RECOMMENDATIONS ===${NC}" >> "$visual_report"
    
    if (( $(echo "$file_integrity < 80" | bc -l) )); then
        echo "- Investigate file integrity issues (Score: $file_integrity)" >> "$visual_report"
    fi
    
    if (( $(echo "$user_accounts < 90" | bc -l) )); then
        echo "- Review user account configurations (Score: $user_accounts)" >> "$visual_report"
    fi
    
    if (( $(echo "$firewall < 85" | bc -l) )); then
        echo "- Strengthen firewall rules (Score: $firewall)" >> "$visual_report"
    fi
    
    if (( $(echo "$audit < 75" | bc -l) )); then
        echo "- Improve audit configuration (Score: $audit)" >> "$visual_report"
    fi
    
    if (( $(echo "$suricata < 70" | bc -l) )); then
        echo "- Check Suricata IDS/IPS configuration (Score: $suricata)" >> "$visual_report"
    fi
    
    # Display the report
    cat "$visual_report"
}

check_file_integrity() {
    # Simulate file integrity check
    local score=$((80 + RANDOM % 20))
    cat <<EOF
{
    "status": "$(if [ $score -gt 85 ]; then echo "good"; else echo "needs improvement"; fi)",
    "score": $score,
    "issues": $(if [ $score -lt 85 ]; then echo 3; else echo 0; fi)
}
EOF
}

check_user_accounts() {
    # Simulate user account check
    local score=$((85 + RANDOM % 15))
    cat <<EOF
{
    "status": "$(if [ $score -gt 90 ]; then echo "excellent"; else echo "good"; fi)",
    "score": $score,
    "issues": $(if [ $score -lt 90 ]; then echo 2; else echo 0; fi)
}
EOF
}

check_firewall() {
    # Simulate firewall check
    local score=$((75 + RANDOM % 25))
    cat <<EOF
{
    "status": "$(if [ $score -gt 85 ]; then echo "strong"; elif [ $score -gt 70 ]; then echo "adequate"; else echo "weak"; fi)",
    "score": $score,
    "issues": $(if [ $score -lt 85 ]; then echo 4; else echo 0; fi)
}
EOF
}

check_audit_config() {
    # Simulate audit config check
    local score=$((60 + RANDOM % 35))
    cat <<EOF
{
    "status": "$(if [ $score -gt 75 ]; then echo "sufficient"; else echo "insufficient"; fi)",
    "score": $score,
    "issues": $(if [ $score -lt 75 ]; then echo 5; else echo 1; fi)
}
EOF
}

check_suricata_status() {
    # Check Suricata status
    if pgrep -x "suricata" >/dev/null; then
        local score=$((70 + RANDOM % 25))
        cat <<EOF
{
    "status": "running",
    "score": $score,
    "alerts": $(if [ $score -lt 80 ]; then echo 10; else echo 3; fi)
}
EOF
    else
        cat <<EOF
{
    "status": "not running",
    "score": 0,
    "alerts": 0
}
EOF
    fi
}

# System Status Functions
get_system_status() {
    local command=$1
    local result=$(eval "$command" 2>/dev/null || echo "Unknown")
    echo "$result"
}

se_status() {
    get_system_status "sestatus | grep 'Current mode' | awk {'print \$3'}"
}

firewall_status() {
    get_system_status "systemctl is-active firewalld"
}

network_manager_status() {
    get_system_status "systemctl is-active NetworkManager"
}

clam_status() {
    get_system_status "systemctl is-active clamav-freshclam"
}

fail2ban_status() {
    get_system_status "systemctl is-active fail2ban"
}

suricata_status() {
    if pgrep -x "suricata" >/dev/null; then
        echo "Running"
    else
        echo "Not running"
    fi
}

app_disk_usage() {
    get_system_status "du -h $APPDIR | tail -1 | awk '{print \$1}'"
}

num_quarantine() {
    find "$QUARANTINE_DIR" -type f | wc -l
}

# EDR Baseline Functions
create_baseline() {
    echo "Creating system baseline..."
    
    # File system baseline
    echo "Creating filesystem baseline..."
    find / -type f -exec stat --format="%n,%U,%G,%a,%F,%y,%z" {} \; 2>/dev/null > "$BASELINE_DIR/filesystem.csv"
    
    # Process baseline
    echo "Creating process baseline..."
    ps -eo pid,user,group,cmd > "$BASELINE_DIR/processes.txt"
    
    # Network baseline
    echo "Creating network baseline..."
    netstat -tulnp > "$BASELINE_DIR/network.txt"
    
    # User/group baseline
    echo "Creating user/group baseline..."
    cat /etc/passwd > "$BASELINE_DIR/passwd.baseline"
    cat /etc/group > "$BASELINE_DIR/group.baseline"
    cat /etc/shadow > "$BASELINE_DIR/shadow.baseline" 2>/dev/null
    
    # Kernel modules
    echo "Creating kernel modules baseline..."
    lsmod > "$BASELINE_DIR/kernel_modules.txt"
    
    # Cron jobs
    echo "Creating cron jobs baseline..."
    crontab -l > "$BASELINE_DIR/crontab_root.txt" 2>/dev/null
    for user in $(cut -f1 -d: /etc/passwd); do
        crontab -u "$user" -l > "$BASELINE_DIR/crontab_$user.txt" 2>/dev/null
    done
    
    # Suricata rules checksum
    if [ -f "/etc/suricata/suricata.yaml" ]; then
        md5sum /etc/suricata/suricata.yaml > "$BASELINE_DIR/suricata_checksum.txt"
    fi
    
    log_event "baseline" "info" "System baseline created"
    echo "System baseline created at $BASELINE_DIR"
}

check_deviations() {
    echo "Checking for system deviations from baseline..."
    
    # Check filesystem changes
    if [ -f "$BASELINE_DIR/filesystem.csv" ]; then
        echo -e "\n[+] Checking for filesystem changes..."
        find / -type f -exec stat --format="%n,%U,%G,%a,%F,%y,%z" {} \; 2>/dev/null > "$BASELINE_DIR/filesystem_current.csv"
        diff "$BASELINE_DIR/filesystem.csv" "$BASELINE_DIR/filesystem_current.csv" | grep '^>' | while read -r line; do
            log_event "filesystem" "warning" "File change detected: ${line:2}"
        done
    fi
    
    # Check user/group changes
    echo -e "\n[+] Checking for user/group changes..."
    if [ -f "$BASELINE_DIR/passwd.baseline" ]; then
        diff "$BASELINE_DIR/passwd.baseline" /etc/passwd | grep '^>' | while read -r line; do
            log_event "user" "alert" "User account change: ${line:2}"
        done
    fi
    
    if [ -f "$BASELINE_DIR/group.baseline" ]; then
        diff "$BASELINE_DIR/group.baseline" /etc/group | grep '^>' | while read -r line; do
            log_event "user" "alert" "Group change: ${line:2}"
        done
    fi
    
    # Check kernel modules
    echo -e "\n[+] Checking for kernel module changes..."
    lsmod > "$BASELINE_DIR/kernel_modules_current.txt"
    if [ -f "$BASELINE_DIR/kernel_modules.txt" ]; then
        diff "$BASELINE_DIR/kernel_modules.txt" "$BASELINE_DIR/kernel_modules_current.txt" | grep '^>' | while read -r line; do
            log_event "kernel" "warning" "Kernel module change: ${line:2}"
        done
    fi
    
    # Check cron jobs
    echo -e "\n[+] Checking for cron job changes..."
    crontab -l > "$BASELINE_DIR/crontab_root_current.txt" 2>/dev/null
    if [ -f "$BASELINE_DIR/crontab_root.txt" ]; then
        diff "$BASELINE_DIR/crontab_root.txt" "$BASELINE_DIR/crontab_root_current.txt" | grep '^>' | while read -r line; do
            log_event "cron" "alert" "Root cron job change: ${line:2}"
        done
    fi
    
    for user in $(cut -f1 -d: /etc/passwd); do
        crontab -u "$user" -l > "$BASELINE_DIR/crontab_${user}_current.txt" 2>/dev/null
        if [ -f "$BASELINE_DIR/crontab_$user.txt" ]; then
            diff "$BASELINE_DIR/crontab_$user.txt" "$BASELINE_DIR/crontab_${user}_current.txt" | grep '^>' | while read -r line; do
                log_event "cron" "alert" "User cron job change ($user): ${line:2}"
            done
        fi
    done
    
    # Check Suricata configuration
    if [ -f "$BASELINE_DIR/suricata_checksum.txt" ]; then
        current_checksum=$(md5sum /etc/suricata/suricata.yaml 2>/dev/null)
        if [ "$current_checksum" != "$(cat $BASELINE_DIR/suricata_checksum.txt)" ]; then
            log_event "suricata" "warning" "Suricata configuration has changed"
        fi
    fi
    
    echo "Deviation check completed. Review $EVENT_LOG for details."
}

# EDR Monitoring Functions
monitor_processes() {
    echo "Starting process monitoring with EDR rules..."
    
    # Load process rules
    declare -A process_rules
    while IFS=: read -r process severity action; do
        [[ "$process" =~ ^# ]] || [[ -z "$process" ]] && continue
        process_rules["$process"]="$severity:$action"
    done < "$RULES_DIR/process_rules.txt"
    
    # Monitor processes
    while true; do
        for process in "${!process_rules[@]}"; do
            if pgrep -x "$process" >/dev/null; then
                IFS=: read -r severity action <<< "${process_rules[$process]}"
                details="Suspicious process detected: $process (Severity: $severity)"
                
                case $action in
                    "alert")
                        log_event "process" "$severity" "$details"
                        ;;
                    "kill")
                        log_event "process" "$severity" "$details - Process killed"
                        pkill -9 "$process"
                        ;;
                    "quarantine")
                        log_event "process" "$severity" "$details - Process quarantined"
                        pkill -9 "$process"
                        # Additional quarantine actions would go here
                        ;;
                    *)
                        log_event "process" "$severity" "$details"
                        ;;
                esac
            fi
        done
        sleep 10
    done
}

monitor_files() {
    echo "Starting file monitoring with EDR rules..."
    
    # Load file rules
    declare -A file_rules
    while IFS=: read -r path perm_change content_change; do
        [[ "$path" =~ ^# ]] || [[ -z "$path" ]] && continue
        file_rules["$path"]="$perm_change:$content_change"
    done < "$RULES_DIR/file_rules.txt"
    
    # Monitor files
    for path in "${!file_rules[@]}"; do
        IFS=: read -r perm_change content_change <<< "${file_rules[$path]}"
        
        if [ -e "$path" ]; then
            # Check permission changes
            current_perm=$(stat -c "%a" "$path" 2>/dev/null)
            original_perm=$(grep "$path," "$BASELINE_DIR/filesystem.csv" 2>/dev/null | cut -d, -f4)
            
            if [ -n "$original_perm" ] && [ "$current_perm" != "$original_perm" ]; then
                log_event "file" "$perm_change" "Permission change detected: $path (from $original_perm to $current_perm)"
            fi
            
            # Check content changes (simplified)
            if [ -f "$path" ]; then
                current_hash=$(md5sum "$path" | awk '{print $1}' 2>/dev/null)
                original_hash=$(grep "$path," "$BASELINE_DIR/filesystem.csv" 2>/dev/null | cut -d, -f1 | md5sum | awk '{print $1}' 2>/dev/null)
                
                if [ -n "$original_hash" ] && [ "$current_hash" != "$original_hash" ]; then
                    log_event "file" "$content_change" "Content change detected: $path"
                fi
            fi
        fi
    done
}

# Scanning Functions
scan_with_clamav() {
    local path=$1
    clamscan --infected --recursive --verbose --no-summary "$path" 2>&1
}

scan_with_maldet() {
    local path=$1
    /usr/local/sbin/maldet --scan "$path" 2>&1
}

scan_with_suricata() {
    local path=$1
    local suricata_log="${SURICATA_LOGS}/scan_$(date +%Y%m%d%H%M%S).log"
    
    # Run Suricata in pcap processing mode
    suricata -r "$path" -l "$SURICATA_LOGS" > "$suricata_log" 2>&1
    
    # Check for alerts
    if grep -q "alert" "${SURICATA_LOGS}/fast.log"; then
        echo "Suricata alerts detected in scan:"
        grep "alert" "${SURICATA_LOGS}/fast.log"
        return 1
    else
        echo "No Suricata alerts detected"
        return 0
    fi
}

check_file_signatures() {
    local file_path=$1
    local file_hash=$(md5sum "$file_path" | awk '{print $1}' 2>/dev/null)
    
    if [ -z "$file_hash" ]; then
        echo "Error: Could not calculate hash"
        return 1
    fi
    
    while IFS= read -r line; do
        if [[ ! "$line" =~ ^# ]] && [[ "$line" =~ "$file_hash:" ]]; then
            echo "${line#*:}"
            return 0
        fi
    done < "$MALWARE_SIGNATURES"
    
    echo "Clean"
}

scan_directory() {
    local path=$1
    local scan_type=$2
    local infected_files=()
    
    case $scan_type in
        clamav)
            echo "Running ClamAV scan on $path"
            scan_with_clamav "$path"
            ;;
        maldet)
            echo "Running Maldet scan on $path"
            scan_with_maldet "$path"
            ;;
        signature)
            echo "Running signature scan on $path"
            while IFS= read -r -d '' file; do
                result=$(check_file_signatures "$file")
                if [ "$result" != "Clean" ]; then
                    echo "Found infected file: $file (Signature: $result)"
                    infected_files+=("$file")
                    
                    # Quarantine the file
                    quarantine_path="${file/$path/$QUARANTINE_DIR}"
                    mkdir -p "$(dirname "$quarantine_path")"
                    mv "$file" "$quarantine_path"
                    
                    log_event "quarantine" "high" "File quarantined: $file (Signature: $result)"
                    
                    # Check threat intelligence if configured
                    if [ -n "${THREAT_INTEL_API}" ]; then
                        threat_info=$(check_threat_intel "$file_hash" "hash")
                        if [ -n "$threat_info" ]; then
                            log_event "threat" "critical" "Known malicious file detected: $file (Threat: $threat_info)"
                        fi
                    fi
                fi
            done < <(find "$path" -type f -print0)
            
            if [ ${#infected_files[@]} -eq 0 ]; then
                echo "No infected files found"
            else
                echo "Quarantined ${#infected_files[@]} files"
            fi
            ;;
        suricata)
            echo "Running Suricata IDS scan on $path"
            scan_with_suricata "$path"
            ;;
        *)
            echo "Invalid scan type. Available options: clamav, maldet, signature, suricata"
            return 1
            ;;
    esac
}

# Quarantine Management
list_quarantine() {
    find "$QUARANTINE_DIR" -type f
}

restore_file() {
    local filename=$1
    local original_path="${filename/$QUARANTINE_DIR/}"
    
    if [ ! -f "$filename" ]; then
        echo "Error: File not found in quarantine"
        return 1
    fi
    
    mkdir -p "$(dirname "$original_path")"
    mv "$filename" "$original_path"
    echo "Restored $filename to $original_path"
    log_event "quarantine" "info" "File restored from quarantine: $filename to $original_path"
}

delete_file() {
    local filename=$1
    
    if [ ! -f "$filename" ]; then
        echo "Error: File not found in quarantine"
        return 1
    fi
    
    rm -f "$filename"
    echo "Permanently deleted $filename"
    log_event "quarantine" "info" "File permanently deleted from quarantine: $filename"
}

# Network Functions
check_malicious_connections() {
    local malicious_ips=()
    
    if [ -f "$MALICIOUS_IPS" ]; then
        while IFS= read -r line; do
            [[ "$line" =~ ^# ]] || [[ -z "$line" ]] || malicious_ips+=("$line")
        done < "$MALICIOUS_IPS"
    fi
    
    echo "Checking for malicious connections..."
    netstat -tunap | awk '/ESTABLISHED/ {print $5, $7}' | while read -r raddr pid_proc; do
        ip=$(echo "$raddr" | cut -d: -f1)
        pid=$(echo "$pid_proc" | cut -d'/' -f1)
        
        for malicious_ip in "${malicious_ips[@]}"; do
            if [ "$ip" == "$malicious_ip" ]; then
                process=$(ps -p "$pid" -o comm= 2>/dev/null || echo "Unknown")
                details="Malicious connection detected: PID: $pid, Process: $process, Remote IP: $ip, Port: $(echo "$raddr" | cut -d: -f2)"
                log_event "network" "critical" "$details"
                echo "$details"
                
                # Check threat intelligence if configured
                if [ -n "${THREAT_INTEL_API}" ]; then
                    threat_info=$(check_threat_intel "$ip" "ip")
                    if [ -n "$threat_info" ]; then
                        log_event "threat" "critical" "Known malicious connection detected: $ip (Threat: $threat_info)"
                        contain_threat "critical" "network" "$ip"
                    fi
                fi
            fi
        done
    done
    
    # Check Suricata alerts for malicious connections
    if [ -f "${SURICATA_LOGS}/fast.log" ]; then
        grep "ET.*MALWARE" "${SURICATA_LOGS}/fast.log" | while read -r alert; do
            log_event "suricata" "high" "Suricata malware alert: $alert"
            echo "Suricata malware alert: $alert"
        done
    fi
}

check_abnormal_ports() {
    echo "Checking for abnormal listening ports..."
    netstat -tunlp | awk '/LISTEN/ {print $4, $7}' | while read -r laddr pid_proc; do
        port=$(echo "$laddr" | rev | cut -d: -f1 | rev)
        pid=$(echo "$pid_proc" | cut -d'/' -f1)
        
        # Common ports to ignore
        case $port in
            20|21|22|23|25|53|80|110|143|443|465|587|993|995|3306|3389)
                continue
                ;;
        esac
        
        if [ "$port" -gt 1024 ]; then
            process=$(ps -p "$pid" -o comm= 2>/dev/null || echo "Unknown")
            details="Abnormal port detected: Port: $port, PID: $pid, Process: $process"
            log_event "network" "warning" "$details"
            echo "$details"
        fi
    done
}

# System Monitoring
check_abnormal_processes() {
    echo "Checking for abnormal processes..."
    ps -eo pid,%cpu,%mem,comm --sort=-%cpu | awk 'NR>1 && ($2 > 80 || $3 > 30) {
        details="High resource usage: PID: "$1", CPU: "$2"%, MEM: "$3"%, Process: "$4
        log_event "process", "warning", details
        printf "%s\n\n", details
    }'
    
    echo "Checking for hidden/deleted executables..."
    find /proc/[0-9]*/exe -type l -exec ls -l {} + 2>/dev/null | grep '(deleted)' | while read -r line; do
        pid=$(echo "$line" | awk -F'/' '{print $3}')
        process=$(ps -p "$pid" -o comm= 2>/dev/null || echo "Unknown")
        details="Deleted executable still running: PID: $pid, Process: $process, Executable: $(echo "$line" | awk '{print $11}')"
        log_event "process" "alert" "$details"
        echo "$details"
    done
}

# Vulnerability Scanning
vulnerability_scan() {
    echo "Running vulnerability scan..."
    
    echo -e "\nWorld-writable files:"
    find / -xdev -type f -perm -0002 2>/dev/null | while read -r file; do
        log_event "vulnerability" "medium" "World-writable file: $file"
        echo "$file"
    done
    
    echo -e "\nSUID/SGID files:"
    find / -xdev -type f -perm -4000 -o -perm -2000 2>/dev/null | while read -r file; do
        log_event "vulnerability" "medium" "SUID/SGID file: $file"
        echo "$file"
    done
    
    echo -e "\nPending system updates:"
    if command -v apt-get &>/dev/null; then
        updates=$(apt list --upgradable 2>/dev/null)
        if [ -n "$updates" ]; then
            log_event "vulnerability" "high" "Pending system updates available"
            echo "$updates"
        fi
    elif command -v yum &>/dev/null; then
        updates=$(yum list updates 2>/dev/null)
        if [ -n "$updates" ]; then
            log_event "vulnerability" "high" "Pending system updates available"
            echo "$updates"
        fi
    else
        echo "Could not determine package manager"
    fi
    
    # Check Suricata rules freshness
    if [ -f "$SURICATA_DIR/last_update" ]; then
        local last_update=$(date -r "$SURICATA_DIR/last_update" +%s)
        local current_time=$(date +%s)
        
        if (( current_time - last_update > 604800 )); then # 7 days
            log_event "vulnerability" "high" "Suricata rules are outdated (last updated: $(date -d @$last_update))"
            echo "Suricata rules are outdated (last updated: $(date -d @$last_update))"
        fi
    fi
}

# Threat Hunting
hunt_suspicious_activity() {
    echo "Hunting for suspicious activity..."
    
    # Check for SSH brute force attempts
    echo -e "\nSSH login attempts:"
    grep "Failed password" /var/log/auth.log 2>/dev/null || grep "Failed password" /var/log/secure 2>/dev/null | \
    awk '{print $1,$2,$3,$9,$11}' | sort | uniq -c | sort -nr | while read -r line; do
        count=$(echo "$line" | awk '{print $1}')
        ip=$(echo "$line" | awk '{print $5}')
        if [ "$count" -gt 5 ]; then
            details="Possible SSH brute force attempt from $ip ($count attempts)"
            log_event "threat" "high" "$details"
            echo "$details"
            
            # Check threat intelligence if configured
            if [ -n "${THREAT_INTEL_API}" ]; then
                threat_info=$(check_threat_intel "$ip" "ip")
                if [ -n "$threat_info" ]; then
                    log_event "threat" "critical" "Known malicious SSH attempt from: $ip (Threat: $threat_info)"
                fi
            fi
        fi
    done
    
    # Check for suspicious commands in history
    echo -e "\nSuspicious commands in bash history:"
    for user in $(cut -f1 -d: /etc/passwd); do
        home=$(eval echo "~$user")
        if [ -f "$home/.bash_history" ]; then
            grep -E "(wget|curl|chmod|chown|ssh|scp|nc|socat|telnet|ftp|lynx|whois) " "$home/.bash_history" | \
            while read -r cmd; do
                details="Suspicious command in $user's history: $cmd"
                log_event "threat" "medium" "$details"
                echo "$details"
            done
        fi
    done
    
    # Check for unusual cron jobs
    echo -e "\nUnusual cron jobs:"
    find /etc/cron* /var/spool/cron -type f -exec grep -vE "^#" {} \; | \
    grep -E "(wget|curl|chmod|chown|ssh|scp|nc|socat|telnet|ftp|lynx|whois) " | \
    while read -r line; do
        details="Suspicious cron job: $line"
        log_event "threat" "high" "$details"
        echo "$details"
    done
    
    # Check Suricata alerts
    echo -e "\nRecent Suricata alerts:"
    if [ -f "${SURICATA_LOGS}/fast.log" ]; then
        grep "alert" "${SURICATA_LOGS}/fast.log" | tail -n 10 | while read -r alert; do
            details="Suricata alert: $alert"
            log_event "suricata" "medium" "$details"
            echo "$details"
        done
    fi
    
    # Perform behavioral analysis
    analyze_behavior
}

# Enterprise EDR Main Execution
enterprise_edr_scan() {
    # Prevent multiple runs
    if [ -e "${LOCK_FILE}" ]; then
        pid=$(cat "${LOCK_FILE}")
        if ps -p "${pid}" > /dev/null; then
            exit 0
        fi
    fi
    echo $$ > "${LOCK_FILE}"
    
    # Initialize
    current_date=$(date +%Y%m%d)
    
    # Start enterprise scan
    log_event "INFO" "Starting enterprise EDR scan (v${VERSION})"
    
    # Behavioral analysis
    analyze_behavior
    
    # Threat detection modules
    check_malicious_connections
    check_abnormal_ports
    check_abnormal_processes
    hunt_suspicious_activity
    
    # Compliance reporting
    generate_compliance_report
    
    # Cleanup
    rm -rf "${TEMP_DIR}"
    rm -f "${LOCK_FILE}"
    
    log_event "INFO" "Enterprise EDR scan completed"
}

# Main function
main() {
    init_directories
    
    if [ $# -eq 0 ]; then
        echo -e "${BLUE}LinuxAV-Solutions Command Line Tool with Enterprise EDR${NC}"
        echo -e "Version: ${GREEN}$VERSION${NC}"
        echo -e "Suricata IDS/IPS: $(suricata_status)"
        echo "Usage: $0 [OPTION]..."
        echo
        echo "Options:"
        echo "  --status                  Show system security status"
        echo "  --scan PATH [--type TYPE] Scan a directory (types: clamav, maldet, signature, suricata)"
        echo "  --quarantine [--list]     List quarantined files"
        echo "  --quarantine --restore FILE  Restore a file from quarantine"
        echo "  --quarantine --delete FILE    Permanently delete a quarantined file"
        echo "  --network-connections     Check for malicious network connections"
        echo "  --network-ports           Check for abnormal listening ports"
        echo "  --processes               Check for abnormal processes"
        echo "  --vulnerability           Run vulnerability scan"
        echo "  --edr-baseline            Create system baseline for EDR"
        echo "  --edr-deviations          Check for system deviations from baseline"
        echo "  --edr-monitor-processes   Start EDR process monitoring"
        echo "  --edr-monitor-files       Run EDR file monitoring"
        echo "  --edr-threat-hunt         Perform threat hunting"
        echo "  --edr-events [--last N]   Show EDR events (last N events)"
        echo "  --enterprise-scan         Run comprehensive enterprise EDR scan"
        echo "  --help                    Show this help message"
        return 1
    fi
    
    while [ $# -gt 0 ]; do
        case $1 in
            --status)
                echo -e "${BLUE}=== System Security Status ===${NC}"
                echo -e "SELinux Status: $(se_status)"
                echo -e "Firewall Status: $(firewall_status)"
                echo -e "Network Manager Status: $(network_manager_status)"
                echo -e "ClamAV Status: $(clam_status)"
                echo -e "Fail2Ban Status: $(fail2ban_status)"
                echo -e "Suricata Status: $(suricata_status)"
                echo -e "Quarantine Items: $(num_quarantine)"
                echo -e "App Disk Usage: $(app_disk_usage)"
                echo -e "Enterprise EDR Version: $VERSION"
                echo -e "Central Management: ${CENTRAL_MGMT_SERVER:-Not configured}"
                shift
                ;;
            --scan)
                if [ -z "$2" ]; then
                    echo -e "${RED}Error: No path specified for scan${NC}"
                    return 1
                fi
                path=$2
                shift 2
                
                scan_type="signature"
                if [ "$1" == "--type" ]; then
                    scan_type=$2
                    shift 2
                fi
                
                scan_directory "$path" "$scan_type"
                ;;
            --quarantine)
                case $2 in
                    --list)
                        echo -e "${BLUE}Quarantined files:${NC}"
                        list_quarantine
                        shift 2
                        ;;
                    --restore)
                        if [ -z "$3" ]; then
                            echo -e "${RED}Error: No file specified for restore${NC}"
                            return 1
                        fi
                        restore_file "$3"
                        shift 3
                        ;;
                    --delete)
                        if [ -z "$3" ]; then
                            echo -e "${RED}Error: No file specified for deletion${NC}"
                            return 1
                        fi
                        delete_file "$3"
                        shift 3
                        ;;
                    *)
                        echo -e "${BLUE}Quarantined files:${NC}"
                        list_quarantine
                        shift
                        ;;
                esac
                ;;
            --network-connections)
                check_malicious_connections
                shift
                ;;
            --network-ports)
                check_abnormal_ports
                shift
                ;;
            --processes)
                check_abnormal_processes
                shift
                ;;
            --vulnerability)
                vulnerability_scan
                shift
                ;;
            --edr-baseline)
                create_baseline
                shift
                ;;
            --edr-deviations)
                check_deviations
                shift
                ;;
            --edr-monitor-processes)
                monitor_processes
                shift
                ;;
            --edr-monitor-files)
                monitor_files
                shift
                ;;
            --edr-threat-hunt)
                hunt_suspicious_activity
                shift
                ;;
            --edr-events)
                if [ "$2" == "--last" ]; then
                    count=$3
                    echo -e "${BLUE}=== Last $count EDR Events ===${NC}"
                    tail -n "$count" "$EVENT_LOG" | awk -F, '{printf "[%s] %-7s %s\n", $1, $2, $3}'
                    shift 3
                else
                    echo -e "${BLUE}=== EDR Events ===${NC}"
                    cat "$EVENT_LOG" | awk -F, '{printf "[%s] %-7s %s\n", $1, $2, $3}'
                    shift
                fi
                ;;
            --enterprise-scan)
                enterprise_edr_scan
                shift
                ;;
            --help)
                main
                return 0
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                return 1
                ;;
        esac
    done
}

# Run the script
main "$@"